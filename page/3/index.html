<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Spring's Idea" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
<meta property="og:type" content="website">
<meta property="og:title" content="Spring&#39;s Idea">
<meta property="og:url" content="https://www.wanglichun.tech/page/3/index.html">
<meta property="og:site_name" content="Spring&#39;s Idea">
<meta property="og:description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Spring Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.wanglichun.tech/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Spring's Idea</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f5aa4ee55174bece95c607a5becef769";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Spring's Idea</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2020/01/16/FCOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/16/FCOS/" class="post-title-link" itemprop="url">FCOS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-16 08:21:19 / 修改时间：13:27:00" itemprop="dateCreated datePublished" datetime="2020-01-16T08:21:19+08:00">2020-01-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Detection/" itemprop="url" rel="index">
                    <span itemprop="name">Detection</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/16/FCOS/" class="post-meta-item leancloud_visitors" data-flag-title="FCOS" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/16/FCOS/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/16/FCOS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>FCOS算法也是一篇anchor free的目标检测算法，但是其思想跟CornerNet系列有点不太一样，CornerNet系列的核心思想是通过Corner pooling来检测角点，然后对角点进行配对，最终得到检测结果，而FCOS方法借鉴了FCN的思想，对每个像素进行直接预测，预测的目标是到bounding box的上、下、左、右边的距离，非常的直观，另外为了处理gt重合的的时候，无法准确判断像素所属类别，作者引入了FPN结构，利用不同的层来处理不同的目标框，另外为了减少误检框，作者又引入了Center-ness layer，过滤掉大部分的误检框。FCOS的主干结构采用的是RetinaNet结构。</p>
</blockquote>
<hr>
<p><strong>论文名称:FCOS:Fully Convolutional One-Stage Object Detection</strong></p>
<p><strong>作者：Zhi Tian &amp; Chunhua Shen等</strong></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1904.01355"><strong>论文链接</strong>：https://arxiv.org/abs/1904.01355</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tianzhi0549/FCOS/"><strong>代码链接</strong>：https://github.com/tianzhi0549/FCOS/</a></p>
<hr>
<p><strong>下面详细介绍一下这篇文章</strong></p>
<p>Object detection是计算机视觉的一个重要的分支，其解决的问题是在一张图像中，找到图像中的目标并给出目标的类别以及坐标框，过去几年，Object detection取得了可喜的成果，很多的算法被提出，目标检测的精度也越来越高，这其中就包括：Faster RCNN,SSD,YOLO v2,v3等，这些方法有一个共同的特点，就是都是基于anchor的，可以说，过去几年，anchor是目标检测算法的灵魂，但是基于anchor的算法同样面临着几个问题：</p>
<ul>
<li>anchor的设计非常重要，超参数的设计比较难。</li>
<li>anchor难以覆盖所有形状的目标，泛化能力较差。</li>
<li>为了取得较好的召回率，通常需要选取大量的anchor，计算量以及显存消耗都比较大。</li>
</ul>
<p>那么既然基于anchor的算法存在这样的问题，我们是否可以抛弃anchor，直接进行目标检测呢？即anchor free算法。<br>本文便是其一。</p>
<p>作者的灵感来源于FCN，FCN可以使用在语义分割、关键点估计、深度估计等各个方面，唯独目标检测领域没有使用FCN，最主要的原因就在于对于anchor的依赖，那么我们是否可以大胆的将FCN应用于目标检测领域呢？使之成为统一的整体？作者就是这样干的，并且取得了比较理想的效果。</p>
<p>其实在作者之前也有人使用FCN方法进行目标检测，比如DenseBox，这个网络有必要说一下，其也算是一个想法比较大胆的网络，其使用FCN-based方法，对每点预测4个向量，分别是到上下左右四条边的距离，后面你会发现，其实本文也是这么干的，但是为了克服bounding box的尺度多样性（比如，图像中的大目标和小目标，回归的尺度范围不一样，大目标需要的值大一点，小目标相对小一点，这样就比较难统一），所以DenseBox在训练的时候将图像缩放到统一尺度，在预测的时候使用图像金字塔处理，但这其实脱离了FCN只计算一次的本质，并且召回比较低，另外DenseBox还遇到一个比较棘手的问题是，bounding box重合的时候，较难处理，如下图所示，那个点到底是要回归球拍还是回归人，因为无法判断该像素的类别以及目标，所以当时DenseBox值在场景检测、关键点检测方面效果较好，在目标检测效果不是很好。</p>
<p><img src="/0.png" alt="0.png"></p>
<p>本文作者就是在DenseBox的基础上，解决了上面提到的问题，取得了较不错的效果。</p>
<p>另外提到anchor free方法就不得不提一下anchor free方法的鼻祖：CornerNet，CornerNet的思想跟本文的思想还是有差别的，CornerNet的主要思想是在检测坐标框的时候，我不是一下检测整个坐标框（需要4个坐标），而是检测左上角点和右下角点（2个坐标），这样相比较于4个坐标，就相对简单一点，然后检测出左上角点和右下角点之后，再将其组合筛选出bounding box，筛选的过程需要较复杂的后处理逻辑。</p>
<p><strong>介绍了这么多的背景，下面该本文的主角出场了</strong></p>
<p>首先，介绍一下FCOS的预测目标，如果是基于anchor的方法，需要提取anchor然后通过anchor的变换来逼近目标，但是FCOS是anchor free的，那么它该如何求的目标呢？这里就是采用了FCN的套路，直接对每个坐标点进行预测，预测的目标呢，就如下图所示，分别是该点对应目标的上下左右四条边的距离。至于前面DenseBox提到的坐标框重合的情况，这里先忽略这个问题，先选择小的坐标框进行回归，后面会有方法解决它。</p>
<p><img src="/1.png" alt="1.png"></p>
<p>这就带来了一个好处，就是FCOS可以使用的正样本的数量就会很多了，相比较于基于anchor的方法，这或许也是该方法取得较好的效果的原因。</p>
<p>网络的输出依然包括分类和检测分支，分类分支通过卷积，输出是80维的向量，代表的是80个类别，并且80个类别接的是sigmoid，这点跟RetinaNet一致，检测分支输出的4维的向量，分别对应点到上下左右边的距离，模型结构如下图Figure 2所示，另外训练的时候，Classification采用的是focal loss，Regression采用的是IOU loss（IOU loss其实也很简单，就是- ln(IOU)，详情可以参考论文：UnitBox），这里跟基于anchor的RetinaNet不太一样，RetinaNet回归使用的是smooth L1 loss。另外需要说明的是，网络中的头是共享的。</p>
<p>具体损失函数公式如下：</p>
<p><img src="/2.png" alt="2.png"></p>
<p><img src="/3.png" alt="3.png"></p>
<p><strong>基本网络介绍完了，作者是如何解决重合的边界框的问题的呢？答案就是FPN结构。</strong></p>
<p>作者使用FPN结构，可以将不同的目标框分散到不同的层中进行预测，这样就很大程度上减少了重叠的发生，作者也做了统计，不使用FPN存在大约23.16%的重合框，使用之后，降到了7.14%。并且使用FPN对小目标也有一定的帮助。</p>
<p><img src="/4.png" alt="4.png"></p>
<p>下图所示为使用FPN，multi-level之后的效果，可见使用multi-level之后，mAP几乎翻倍。</p>
<p><img src="/5.png" alt="5.png"></p>
<p>不同于基于anchor的方法，其利用anchor的尺度将不同目标分配到不同层，这里是利用max(l，r，t，b)的范围进行划分的。</p>
<blockquote>
<p>并且由于这里使用的是共享头，但是不用的layer回归的尺度是不一样的，如果都使用相同的标准不太合理，所以这里作者使用了exp(sx)对边界框的回归进行处理，增加了一个比例调节因子s，这样就可以调节它的回归尺度了，比如前面层回归小一些，后面层回归大一些。</p>
</blockquote>
<p><strong>另外为了进一步降低目标的误检，作者引入了Center-ness层</strong></p>
<p>Center-ness层的主要目标就是找到目标的中心点，即离目标中心越近，输出值越大，反之越小，这里作者的实现方式很简单，就是增加了一个1维的分类层的分支，上面的图Figure 2可以看到，而中心的目标定义如下公式，可见最中心的点的centerness为1，距离越远的点，centerness的值越小。</p>
<p><img src="/6.png" alt="6.png"></p>
<p>训练的时候，使用Binary CrossEntropy Loss。</p>
<p>在inference阶段，网络前向之后，将该Center-ness的值与classification的输出值相乘，这样可以有效的过滤掉一批误检框，提高识别准确度。</p>
<p>这里，作者也对比了使用center-ness的效果，结果如下表所示，其中center-ness+，代表的是在检测分支上直接进行中心点的预测，而不是在分类上增加一个分支，结果可以发现（1）在检测分支进行直接预测的结果并没有原来的好，在分类分支增加了center-ness，mAP可以提高大约3个点左右。另外作者也进行了实验，如果center-ness预测的全部都对的情况下（理想情况），mAP可以达到42.1%的准确率，说明其实center-ness还是有提升空间的，所以作者进一步进行了实验，将center-ness加深，结果显示mAP从36.6%提高到了36.8%。</p>
<p><img src="/7.png" alt="7.png"><br><strong>介绍到这里，基本上网络的知识点都介绍完了，下面看一下网络的整体效果</strong></p>
<p>下表，是FCOS与现有比较好的算法的精度对比，可以发现还是具有一定优势的。<br><img src="/8.png" alt="8.png"></p>
<p>由于FCOS网络比较大，所以训练起来对显存的要求还是比较高的，根据作者GitHub的链接显示，训练需要的显存还是比较大的，ResNeXt101需要70G+的显存，估计没有牛逼卡的同学，最多也就可以训一个ResNet 50的，测试速度71ms，不算很快，但也还可以。<br><img src="/9.png" alt="9.png"></p>
<p>另外，FCOS也可以作为two-stage方法的RPN来使用，这里不详述了。感兴趣的读者可以自行了解，原理都是一样的。</p>
<p>本文是一篇anchor free的目标检测方法，主要创新点在于，利用FCN的思想，同时引入了Center-ness层来进行中心度的计算（在anchor free方法中，center还是挺重要的），最终取得的效果还不错，随着算法能力的提升，现在在COCO上，没有个mAP &gt; 0.4都不好意思拿出来秀。</p>
<p><strong>本文为个人理解，如有错误，欢迎指正。</strong></p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/16/FCOS/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2020/01/16/YOLO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/16/YOLO/" class="post-title-link" itemprop="url">YOLO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-16 08:21:19" itemprop="dateCreated datePublished" datetime="2020-01-16T08:21:19+08:00">2020-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-16 13:36:46" itemprop="dateModified" datetime="2020-02-16T13:36:46+08:00">2020-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Detection/" itemprop="url" rel="index">
                    <span itemprop="name">Detection</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/16/YOLO/" class="post-meta-item leancloud_visitors" data-flag-title="YOLO" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/16/YOLO/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/16/YOLO/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><p>YOLO（You Only Look Once）是CVPR2016的一篇文章,是目标检测领域比较有名的的一篇文章，yolo出名不在于它的精度高，而在于他的速度很快，下面介绍的是yolo的第一版，在yolo之后，又改进出了yolo-v2,yolo-v3,v2,v3的精度相比较于v1就有大大提升了，这个后面再详细介绍。</p>
<p>在介绍yolo之前，首先引入一下目标检测的进展，yolo之前的目标检测一般是如何做的呢？</p>
<blockquote>
<p>有两个代表：DPM以及RCNN系列<br>1.DPM：利用sliding window，提取特征(SIFT等)，进行比对<br>2.RCNN: 利用region proposal方法提取，利用网络进行分类，并进行坐标回归预测    </p>
</blockquote>
<p>yolo是怎么做的呢？</p>
<p>yolo直接采用regression（回归）的方法进行坐标框的检测以及分类，使用一个end-to-end的简单网络，直接实现坐标回归与分类，如下图所示</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvpaorx8ij20d907cgny.jpg" alt="http://ww1.sinaimg.cn/large/87675bbbgy1frvpaorx8ij20d907cgny.jpg"></p>
<p><strong>yolo具体是怎么做的呢？</strong></p>
<p>yolo首先将图像分割成S*S个grid(S默认取7)，然后对每个gird，预测B个（bounding box + confidence），（B默认为2）,confidence定义为$P_r(Object)*IOU_{pred}^{truth}$,如果不存在物体，则confidence为0，否则期望其为IOU，bounding box为：[x,y,w,h]其中(x,y)为object中心点坐标</p>
<p>每个gird另外预测C个类别的概率，作者在VOC上实验，所以C取为20（这里为什么不是类似Fast RCNN的21类，因为是否为背景，作者放到了上面的confidence中），<br>在测试过程中将confidence与C类的probability相乘如：$P_r(Class_i|Object)*P_r(Object)*IOU_{pred}^{truth}=P_r(Class_i)*IOU_{pred}^{truth}$就可以得到每个类别的概率以及其bounding box的准确度。</p>
<p><strong>说这么多，大家可能不清晰，那具体的预测过程是怎么样的呢？下面展示一下</strong></p>
<ol>
<li>首先通过20个类与每个grid的2个预测bounding box的confidence相乘，得到该bounding box为每个类的概率，对每个grid都做该操作，将得到7*7*2=98个向量，如下图黄色矩形所示，其中，每一列代表每个预测的bounding box为各个类别的概率值，每一行【<strong>下面图中么有行，可以看下2张图</strong>】对应每个类别，以下2张图中第一个图为例，第一行便对应于dog的概率，第一列则对应于bounging box1.</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvrqzzrjoj21700gm7ec.jpg"></p>
<ol start="2">
<li><p>然后，通过阈值以及非极大值抑制（这步骤比较简单，详细操作过程可以参考这个ppt链接：<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1aeRvtKG21KHdD5lg6Hgyhx5rPq_ZOsGjG5rJ1HP7BbA/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p">yolo操作详细演示PPT</a>，这里就不详细介绍了），将无用的位置为0。</p>
</li>
<li><p>对每一列，找到最大值，并判断score是否为目标。</p>
</li>
</ol>
<p><strong>说完了预测过程，那么yolo是如何训练的呢</strong></p>
<p>yolo的基础网络灵感来源于GoogLeNet，但是并没有采取其inception的结构，而是简单的使用了1×1的卷积核。base model共有24个卷积层，后面接2个全连接层，如下图所示。<br>为了提高速度，作者同时设计了fast yolo结构，只包含9个卷积层，感兴趣的读者可以自行查看。</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbly1frvwaczy2mj20wl0e9jsy.jpg"></p>
<p>在训练网络的时候，作者首先用ImageNet预训练前20个卷积层，作者训练的结果是top-5 accuracy = 88%</p>
<p>训练好分类网络后，进行检测的训练，由于检测一般需要较大的分辨率，所以作者将输入图像大小修改为448*448</p>
<p>另外yolo并没有使用Relu激活函数，而是使用了leaky rectified linear激活函数，如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvwpninw9j207o033jr9.jpg"></p>
<p>在损失函数的设计上，作者选择均方误差作为损失函数。</p>
<blockquote>
<p>但是，仅仅使用均方误差带来了一些问题，如果分类和定位使用同样权重的loss,结果会不理想，在图像中，很多的grid是不包含物体的，这会将confidence score降为0，同时压制了那些有物体部分的梯度，会导致模型不稳定，所以作者修改了检测与分类的loss的权重，增加了bounding box的权重同时减低了没有物体的confidence权重，作者设置$\lambda_{coord}=5,\lambda_{noobj}=0.5$并且不同大小的box同样会带来loss的影响（比如同样是相差10个像素，如果大矩形的大小为100，小矩形的大小为10，那么对于大矩形只相差了0.1，而小矩形相差了1倍），所以作者采用平方根来削弱这个影响</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-bfac676d0f0db4a1d9f4f9aa782341dd_hd.jpg"></p>
<p>最后得到损失函数如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvx70zpdbj20e109tmxk.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f9af0b8094b35f7c2ab2179efb6f4c8c_hd.jpg"></p>
<p>这个损失函数是不是特别美~~</p>
<p><strong>训练细节：</strong></p>
<p>data : VOC2007以及VOC2012<br>epoch : 135<br>batchsize:64<br>momentum:0.9<br>decay:0.0005<br>learning rae schedule: 前75个epoch 10e-2,然后30个epoch 10e-3,最后30个epoch 10e-4</p>
<p><strong>实验结果</strong></p>
<p>首先秀一张识别精度图，YOLO虽然没有Fast R-CNN的mAP高，但是效果挺好的<br><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvzhajespj20iw0bxmyp.jpg"></p>
<p>另外作者通过实验发现，YOLO的精度不高但是对于background的错检率要高于fast rcnn，如下图所示：</p>
<p>其中</p>
<p><strong>Correct: correct class and IOU &gt; 0.5</strong></p>
<p><strong>Localization:correct class 0.1 &lt; IOU &lt; 0.5</strong></p>
<p><strong>Similar : class is similar ,IOU &gt; 0.1</strong></p>
<p><strong>Other : class is wrong  ,IOU &gt; 0.1</strong></p>
<p><strong>background: IOU &lt; 0.1 for any object</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbly1frvy7kblmtj20fg0830t2.jpg"></p>
<p>进而作者想到了将fast rcnn与yolo相结合以提高精度，实验结果证明，确实有提升</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvzibic4xj20hv06jjrx.jpg"></p>
<p><strong>到这基本就介绍完yolo了，总结一下yolo特点：</strong></p>
<p>1.yolo很快，base yolo 45 frames per seconds , fast yolo 可以达到155 frames per seconds, on a Titan X GPU</p>
<p>2.yolo不同于sliding window以及region proposal方法在训练和检测的时候只能看到局部图像，而yolo可以看到全局图像,(这也是导致后面实验中Fast R-CNN的将背景检测错误的概率要高于yolo的原因)<br>为什么说yolo可以看到图像全局特征，这里本人理解应该是对应后面的<strong>两个</strong>全连接层，yolo通过reshape将全连接的结果对应回原图的7*7,使得其可以看到全局的特征</p>
<p><img src="http://ww1.sinaimg.cn/large/87675bbbgy1frvqf22gdtj21b70pgamo.jpg"></p>
<p>3.yolo具有较强的泛化能力,对于艺术品同样具有较好的检测效果</p>
<hr>
<p><strong>补充说明</strong></p>
<p>yolo反向传播的时候如何计算梯度呢？</p>
<p>yolo最终的输出，实际是全连接层，reshape的结果只是方便与前面映射回去，所以在计算梯度的时候，对loss进行求导，在全连接层相应位置映射回去便可以了。<br>详情可参考代码如下：</p>
<p>forward_detection_layer函数中，delta为梯度，读者可执行对应其计算过程<br>make_detection_layer中有初始化过程，读者可以对应其值</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">detection_layer make_detection_layer(<span class="built_in">int</span> batch, <span class="built_in">int</span> inputs, <span class="built_in">int</span> n, <span class="built_in">int</span> side, <span class="built_in">int</span> classes, <span class="built_in">int</span> coords, <span class="built_in">int</span> rescore)</span><br><span class="line">{</span><br><span class="line">    detection_layer l = {<span class="number">0</span>};</span><br><span class="line">    l.<span class="built_in">type</span> = DETECTION;</span><br><span class="line"></span><br><span class="line">    l.n = n;   <span class="comment">##  及论文中 B = 2</span></span><br><span class="line">    l.batch = batch;</span><br><span class="line">    l.inputs = inputs;</span><br><span class="line">    l.classes = classes;</span><br><span class="line">    l.coords = coords;</span><br><span class="line">    l.rescore = rescore;</span><br><span class="line">    l.side = side;    <span class="comment">###  即论文中 S = 7 </span></span><br><span class="line">    l.w = side;</span><br><span class="line">    l.h = side;</span><br><span class="line">    <span class="keyword">assert</span>(side*side*((<span class="number">1</span> + l.coords)*l.n + l.classes) == inputs);</span><br><span class="line">    l.cost = calloc(<span class="number">1</span>, sizeof(<span class="built_in">float</span>));</span><br><span class="line">    l.outputs = l.inputs;</span><br><span class="line">    l.truths = l.side*l.side*(<span class="number">1</span>+l.coords+l.classes);</span><br><span class="line">    l.output = calloc(batch*l.outputs, sizeof(<span class="built_in">float</span>));</span><br><span class="line">    l.delta = calloc(batch*l.outputs, sizeof(<span class="built_in">float</span>));</span><br><span class="line"></span><br><span class="line">    l.forward = forward_detection_layer;</span><br><span class="line">    l.backward = backward_detection_layer;</span><br><span class="line"><span class="comment">#ifdef GPU</span></span><br><span class="line">    l.forward_gpu = forward_detection_layer_gpu;</span><br><span class="line">    l.backward_gpu = backward_detection_layer_gpu;</span><br><span class="line">    l.output_gpu = cuda_make_array(l.output, batch*l.outputs);</span><br><span class="line">    l.delta_gpu = cuda_make_array(l.delta, batch*l.outputs);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    fprintf(stderr, <span class="string">"Detection Layer\n"</span>);</span><br><span class="line">    srand(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void forward_detection_layer(const detection_layer l, network net)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> locations = l.side*l.side;</span><br><span class="line">    <span class="built_in">int</span> i,j;</span><br><span class="line">    memcpy(l.output, net.<span class="built_in">input</span>, l.outputs*l.batch*sizeof(<span class="built_in">float</span>));</span><br><span class="line">    //<span class="keyword">if</span>(l.reorg) reorg(l.output, l.w*l.h, size*l.n, l.batch, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">int</span> b;</span><br><span class="line">    <span class="keyword">if</span> (l.softmax){</span><br><span class="line">        <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; l.batch; ++b){</span><br><span class="line">            <span class="built_in">int</span> index = b*l.inputs;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; locations; ++i) {</span><br><span class="line">                <span class="built_in">int</span> offset = i*l.classes;</span><br><span class="line">                softmax(l.output + index + offset, l.classes, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                        l.output + index + offset);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(net.train){</span><br><span class="line">        <span class="built_in">float</span> avg_iou = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> avg_cat = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> avg_allcat = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> avg_obj = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">float</span> avg_anyobj = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">        *(l.cost) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> size = l.inputs * l.batch;</span><br><span class="line">        memset(l.delta, <span class="number">0</span>, size * sizeof(<span class="built_in">float</span>));</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; l.batch; ++b){</span><br><span class="line">            <span class="built_in">int</span> index = b*l.inputs;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; locations; ++i) {</span><br><span class="line">                <span class="built_in">int</span> truth_index = (b*locations + i)*(<span class="number">1</span>+l.coords+l.classes);</span><br><span class="line">                <span class="built_in">int</span> is_obj = net.truth[truth_index];</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l.n; ++j) {</span><br><span class="line">                    <span class="built_in">int</span> p_index = index + locations*l.classes + i*l.n + j;</span><br><span class="line">                    l.delta[p_index] = l.noobject_scale*(<span class="number">0</span> - l.output[p_index]);</span><br><span class="line">                    *(l.cost) += l.noobject_scale*<span class="built_in">pow</span>(l.output[p_index], <span class="number">2</span>);</span><br><span class="line">                    avg_anyobj += l.output[p_index];</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> best_index = -<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">float</span> best_iou = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">float</span> best_rmse = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!is_obj){</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> class_index = index + i*l.classes;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; l.classes; ++j) {</span><br><span class="line">                    l.delta[class_index+j] = l.class_scale * (net.truth[truth_index+<span class="number">1</span>+j] - l.output[class_index+j]);</span><br><span class="line">                    *(l.cost) += l.class_scale * <span class="built_in">pow</span>(net.truth[truth_index+<span class="number">1</span>+j] - l.output[class_index+j], <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span>(net.truth[truth_index + <span class="number">1</span> + j]) avg_cat += l.output[class_index+j];</span><br><span class="line">                    avg_allcat += l.output[class_index+j];</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                box truth = float_to_box(net.truth + truth_index + <span class="number">1</span> + l.classes, <span class="number">1</span>);</span><br><span class="line">                truth.x /= l.side;</span><br><span class="line">                truth.y /= l.side;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; l.n; ++j){</span><br><span class="line">                    <span class="built_in">int</span> box_index = index + locations*(l.classes + l.n) + (i*l.n + j) * l.coords;</span><br><span class="line">                    box out = float_to_box(l.output + box_index, <span class="number">1</span>);</span><br><span class="line">                    out.x /= l.side;</span><br><span class="line">                    out.y /= l.side;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (l.sqrt){</span><br><span class="line">                        out.w = out.w*out.w;</span><br><span class="line">                        out.h = out.h*out.h;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">float</span> iou  = box_iou(out, truth);</span><br><span class="line">                    //iou = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">float</span> rmse = box_rmse(out, truth);</span><br><span class="line">                    <span class="keyword">if</span>(best_iou &gt; <span class="number">0</span> || iou &gt; <span class="number">0</span>){</span><br><span class="line">                        <span class="keyword">if</span>(iou &gt; best_iou){</span><br><span class="line">                            best_iou = iou;</span><br><span class="line">                            best_index = j;</span><br><span class="line">                        }</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        <span class="keyword">if</span>(rmse &lt; best_rmse){</span><br><span class="line">                            best_rmse = rmse;</span><br><span class="line">                            best_index = j;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(l.forced){</span><br><span class="line">                    <span class="keyword">if</span>(truth.w*truth.h &lt; <span class="number">.1</span>){</span><br><span class="line">                        best_index = <span class="number">1</span>;</span><br><span class="line">                    }<span class="keyword">else</span>{</span><br><span class="line">                        best_index = <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(l.random &amp;&amp; *(net.seen) &lt; <span class="number">64000</span>){</span><br><span class="line">                    best_index = rand()%l.n;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> box_index = index + locations*(l.classes + l.n) + (i*l.n + best_index) * l.coords;</span><br><span class="line">                <span class="built_in">int</span> tbox_index = truth_index + <span class="number">1</span> + l.classes;</span><br><span class="line"></span><br><span class="line">                box out = float_to_box(l.output + box_index, <span class="number">1</span>);</span><br><span class="line">                out.x /= l.side;</span><br><span class="line">                out.y /= l.side;</span><br><span class="line">                <span class="keyword">if</span> (l.sqrt) {</span><br><span class="line">                    out.w = out.w*out.w;</span><br><span class="line">                    out.h = out.h*out.h;</span><br><span class="line">                }</span><br><span class="line">                <span class="built_in">float</span> iou  = box_iou(out, truth);</span><br><span class="line"></span><br><span class="line">                //printf(<span class="string">"%d,"</span>, best_index);</span><br><span class="line">                <span class="built_in">int</span> p_index = index + locations*l.classes + i*l.n + best_index;</span><br><span class="line">                *(l.cost) -= l.noobject_scale * <span class="built_in">pow</span>(l.output[p_index], <span class="number">2</span>);</span><br><span class="line">                *(l.cost) += l.object_scale * <span class="built_in">pow</span>(<span class="number">1</span>-l.output[p_index], <span class="number">2</span>);</span><br><span class="line">                avg_obj += l.output[p_index];</span><br><span class="line">                l.delta[p_index] = l.object_scale * (<span class="number">1.</span>-l.output[p_index]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(l.rescore){</span><br><span class="line">                    l.delta[p_index] = l.object_scale * (iou - l.output[p_index]);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                l.delta[box_index+<span class="number">0</span>] = l.coord_scale*(net.truth[tbox_index + <span class="number">0</span>] - l.output[box_index + <span class="number">0</span>]);</span><br><span class="line">                l.delta[box_index+<span class="number">1</span>] = l.coord_scale*(net.truth[tbox_index + <span class="number">1</span>] - l.output[box_index + <span class="number">1</span>]);</span><br><span class="line">                l.delta[box_index+<span class="number">2</span>] = l.coord_scale*(net.truth[tbox_index + <span class="number">2</span>] - l.output[box_index + <span class="number">2</span>]);</span><br><span class="line">                l.delta[box_index+<span class="number">3</span>] = l.coord_scale*(net.truth[tbox_index + <span class="number">3</span>] - l.output[box_index + <span class="number">3</span>]);</span><br><span class="line">                <span class="keyword">if</span>(l.sqrt){</span><br><span class="line">                    l.delta[box_index+<span class="number">2</span>] = l.coord_scale*(sqrt(net.truth[tbox_index + <span class="number">2</span>]) - l.output[box_index + <span class="number">2</span>]);</span><br><span class="line">                    l.delta[box_index+<span class="number">3</span>] = l.coord_scale*(sqrt(net.truth[tbox_index + <span class="number">3</span>]) - l.output[box_index + <span class="number">3</span>]);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                *(l.cost) += <span class="built_in">pow</span>(<span class="number">1</span>-iou, <span class="number">2</span>);</span><br><span class="line">                avg_iou += iou;</span><br><span class="line">                ++count;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">float</span> *costs = calloc(l.batch*locations*l.n, sizeof(<span class="built_in">float</span>));</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; l.batch; ++b) {</span><br><span class="line">                <span class="built_in">int</span> index = b*l.inputs;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; locations; ++i) {</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l.n; ++j) {</span><br><span class="line">                        <span class="built_in">int</span> p_index = index + locations*l.classes + i*l.n + j;</span><br><span class="line">                        costs[b*locations*l.n + i*l.n + j] = l.delta[p_index]*l.delta[p_index];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">int</span> indexes[<span class="number">100</span>];</span><br><span class="line">            top_k(costs, l.batch*locations*l.n, <span class="number">100</span>, indexes);</span><br><span class="line">            <span class="built_in">float</span> cutoff = costs[indexes[<span class="number">99</span>]];</span><br><span class="line">            <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; l.batch; ++b) {</span><br><span class="line">                <span class="built_in">int</span> index = b*l.inputs;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; locations; ++i) {</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l.n; ++j) {</span><br><span class="line">                        <span class="built_in">int</span> p_index = index + locations*l.classes + i*l.n + j;</span><br><span class="line">                        <span class="keyword">if</span> (l.delta[p_index]*l.delta[p_index] &lt; cutoff) l.delta[p_index] = <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            free(costs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        *(l.cost) = <span class="built_in">pow</span>(mag_array(l.delta, l.outputs * l.batch), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Detection Avg IOU: %f, Pos Cat: %f, All Cat: %f, Pos Obj: %f, Any Obj: %f, count: %d\n"</span>, avg_iou/count, avg_cat/count, avg_allcat/(count*l.classes), avg_obj/count, avg_anyobj/(l.batch*locations*l.n), count);</span><br><span class="line">        //<span class="keyword">if</span>(l.reorg) reorg(l.delta, l.w*l.h, size*l.n, l.batch, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/16/YOLO/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2020/01/15/ACNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/ACNet/" class="post-title-link" itemprop="url">ACNet</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-15 09:02:42 / 修改时间：14:14:20" itemprop="dateCreated datePublished" datetime="2020-01-15T09:02:42+08:00">2020-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Classification/" itemprop="url" rel="index">
                    <span itemprop="name">Classification</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/15/ACNet/" class="post-meta-item leancloud_visitors" data-flag-title="ACNet" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/15/ACNet/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/15/ACNet/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>ACNet，借鉴了模型加速的一些方法，在原始的dxd的卷积上，通过增加并行的1xd以及dx1卷积（即AC Block），实现模型精度的增强，同时在部署阶段，又将dxd、1xd、dx1卷积通过公式进行合并计算得到新的dxd卷积，并没有增加原有dxd卷积的计算量以及inference的时间，精度速度双收，作者将ACBlock应用于多个网络，效果还是比较显著的，值得借鉴。</p>
</blockquote>
<hr>
<p>论文名称：ACNet: Strengthening the Kernel Skeletons for Powerful CNN via Asymmetric Convolution Blocks</p>
<p>作者：Xiaohan Ding &amp; Yuchen Guo 等</p>
<p>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1908.03930">https://arxiv.org/abs/1908.03930</a></p>
<hr>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>提升网络的精度以及速度，一直是广大研究人员孜孜不倦的追求。那么<strong>如何提升网络的精度</strong>？我们可以看看网络的发展，从VGG-&gt;ResNet-&gt;DenseNet-&gt;SENet-&gt;FPN等，网络的结构在逐渐的复杂，从VGG单纯的stack模式，到ResNet引入identity　mapping，到DenseNet的Dense　Connecting以及SENet的attention，FPN的不同特征图的叠加，网络的发展使其变得越来越复杂。<strong>那么如何提升网络的速度</strong>？模型压缩：剪枝、量化。总的来说，大体就是通过各种方法减少计算量，减少运算中的中间变量，减少网络的复杂度。</p>
<p>这篇文章的最大创新点就在于<strong>虽然对网络结构进行了稍微的修改，提出了ACB模块，（网络的修改，结合了Inception论文中的方法，还是挺巧妙的），提高了精度，但是在部署的时候，通过计算合并，并没有增加网络的计算量，保持了原来的速度，下图是ACB模块简单的图示，左边是训练时的结构，右面是部署时的合并</strong>。</p>
<p><img src="/1.png" alt="1.png"></p>
<h3 id="ACB-Asymmetric-Convolution-Block"><a href="#ACB-Asymmetric-Convolution-Block" class="headerlink" title="ACB(Asymmetric Convolution Block)"></a>ACB(Asymmetric Convolution Block)</h3><p>如上图所示，ACB模块就是将原本dxd的卷积，修改为3个平行并列的卷积，分别为原来的dxd以及新增的1xd以及dx1,上图中的展示为d=3的情况，虽然d不限制，不过大部分网络d都是等于3的。然后将3个平行输出的特征图做相加操作。</p>
<p>ACB由于并没有对网络结构进行大的调整，仅仅是调整了3x3的卷积，所以ACB模块可以应用于任何现有的网络，只要替换卷积就可以了。</p>
<p>在inception v3中，已经使用过这种方法，利用1x7和7x1替换原有的7x7的卷积，减少参数量的同时并没有降低精度，但其中也提到替换的结构在网络的低层表现不是很好。</p>
<p>分支可以使用如下Pytorch代码实现，比较简单：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">branch3x3dbl_1 = conv_block(c3, c3, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">branch3x3dbl_2 = conv_block(c3, c3, kernel_size=(<span class="number">3</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">branch3x3dbl_3 = conv_block(c3, c3, kernel_size=(<span class="number">1</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>ACB其实比较简单，下面介绍一下fusion操作吧。</p>
<h3 id="Fusion"><a href="#Fusion" class="headerlink" title="Fusion"></a>Fusion</h3><p>下图所展示的就是卷积的fusion，很好理解，不多介绍了。</p>
<p><img src="/2.png" alt="2.png"></p>
<p>卷积后面接BN是比较常见的操作，下面详细一下带BN的fusion，如下图所示，I代表特征图。</p>
<p><img src="/3.png" alt="3.png"></p>
<p>这张图已经很清晰的描述的计算过程，有的时候一图抵千言，第一行就是原始的操作，BN fusion，可以将每行的I提取出来，就变成了第二行，branch fusion就是将卷积操作合并到一起，然后将后面的参数统一计算成b，因为模型训练完成这些参数都是固定的，也就可以很方便的进行合并计算出来了，这是模型加速时候的常规操作。</p>
<p>还是比较简单的。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>首先在ImageNet上面还是有效果的，可以看到不论是top1还是top5都有一定程度的提升。</p>
<p><img src="/4.png" alt="4.png"></p>
<p><strong>加下来探索一下哪里产生的作用比较大</strong></p>
<p>作者对比了如下三个变量：</p>
<ol>
<li>horizontal kernels</li>
<li>vertical kernels</li>
<li>batch normalization</li>
</ol>
<p>可以发现，horizontal以及vertical kernels都会产生一定的积极效果，结合BN之后，效果就跟明显了。</p>
<p><img src="/5.png" alt="5.png"></p>
<p>另外作者进行实验证明了卷积核的骨架的作用性，下面的实验中，作者在训练好的模型中，分别将卷积核的骨架随机置为0，角点随机置为0以及全部随机置为0，sparsity ratio代表将多少的比例设置为0。可以发现，骨架的影响是最大的，下降幅度非常快，而角点相对来说要慢一点。 </p>
<p><img src="/6.png" alt="6.png"></p>
<p>最后作者探究了kernel内值的重要性，采用的方法就是，利用所有数值的绝对值来当做当前kernel值的重要性，然后对所有的kernel首先进行归一化（layerwise），然后对经过归一化的kernel取均值得到最终的重要性，最终作者得到的结果如下：</p>
<p><img src="/7.png" alt="7.png"></p>
<p>可以看到，正常的kernel分布相对较平均，中间最大达到了0.9以上，其他的基本在0.8以上，但是ACNet使得骨架部分的权重明显增加，这也可以说明ACNet对于骨架部分的增强，使得模型效果的提升（上个实验已经证明了骨架的重要性）</p>
<p>那如果ACNet不是在kernel骨架中间相加，而是在kernel的右下角相加呢？如上图figure 6(c)所示，实验证明，这样对于边界是具有一定的增强作用的，但是在CIFAR上面的表现没有在中间相加的效果好，并且同样采用上面将一部分kernel置为0的方法，结果如下图，右下角的影响变得很大，当然还是没有骨架大，进一步侧面说明的骨架的重要性。</p>
<p><img src="/8.png" alt="8.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文虽然方法都比较简单，但是关键在于想法很不错，利用增强骨架的能力提高模型的效果，同时在部署阶段，使用参数融合，减少计算量，还不影响速度，值得学习借鉴。</p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/15/ACNet/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2020/01/01/foveabox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/foveabox/" class="post-title-link" itemprop="url">FoveaBox</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-01 08:16:43 / 修改时间：13:24:22" itemprop="dateCreated datePublished" datetime="2020-01-01T08:16:43+08:00">2020-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Detection/" itemprop="url" rel="index">
                    <span itemprop="name">Detection</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/01/foveabox/" class="post-meta-item leancloud_visitors" data-flag-title="FoveaBox" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/01/foveabox/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/01/foveabox/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>FoveaBox是CVPR2019的一篇anchor free的目标检测文章，其思想跟FCOS很相似，都是在RetinaNet的基础上，在不同stage输出的特征图上，直接得到目标类别并回归出目标的位置，相比FCOS,FoveaBox要更简单一些，FoveaBox在COCO的精度可以达到42.1。</p>
</blockquote>
<hr>
<p>作者：Tao Kong   Fuchuan Sun 等</p>
<p>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1904.03797">https://arxiv.org/abs/1904.03797</a></p>
<p>代码链接：<a target="_blank" rel="noopener" href="https://github.com/taokong/FoveaBox">https://github.com/taokong/FoveaBox</a></p>
<hr>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li>使用anchor的缺点</li>
</ul>
<ol>
<li>超参数的引入</li>
<li>泛化性不够，对不同的任务需要设计不同的anchor</li>
<li>正负样本不均匀</li>
</ol>
<ul>
<li>灵感来源</li>
</ul>
<ol>
<li>MetaAnchor</li>
<li>Guided-Anchoring</li>
</ol>
<h3 id="FoveaBox"><a href="#FoveaBox" class="headerlink" title="FoveaBox"></a>FoveaBox</h3><p>在介绍FoveaBox之前，首先展示一张FoveaBox的结构图，如下。FoveaBox的整体结构跟RetinaNet基本一致，同样采用FPN结构，同样是不同的level分出两个subnet，一个用于预测类别，一个用于预测坐标框。不一样的地方在于，class subnet最后的输出这里是W*H*K,而RetinaNet是W*H*A*K,没有了anchor的参数A,box subnet的输出也是同理。</p>
<p><img src="/1.png" alt="1.png"></p>
<p>在FoveaBox中，共有5个level分出subnet，分别是$P_{l},l=3,4,…,7$,每个level输出的特征图的大小为$\frac{1}{2^{l}}$</p>
<h4 id="Scale-Assignment"><a href="#Scale-Assignment" class="headerlink" title="Scale Assignment"></a>Scale Assignment</h4><p>由于目标尺寸变换范围较大，FoveaBox跟SSD方法一致，同样采用了不同的level预测不同尺寸的目标的方法，<strong>另外在FCOS中（一个跟FoveaBox很相似的anchor free目标检测方法），解释到，使用多level预测的目的是为了解决anchor free的时候，目标重叠的问题，因为重叠就没有办法分配正负样本了，这样可以有效减少目标重合。</strong></p>
<p>这里作者将7个level的尺寸设置成$32^{2}$-$512^{2}$,用公式表示就是$S_{l}=4^{l}S_{0}$其中$S_{0}=16,l=3,4,…,7$,并且，为了控制不同level之间的重合度，作者增加了$\eta$参数，进一步调节不同level的尺度范围,$[\frac{S_{l}}{\eta_{2}},S_{l}\eta^{2}]$，通过调节参数，一个目标可能会在多个level中进行检测。</p>
<h4 id="Object-Fovea"><a href="#Object-Fovea" class="headerlink" title="Object Fovea"></a>Object Fovea</h4><p>接下来我们来看一下，Fovea在训练中如何定义正负样本。</p>
<p>Fovea是anchor free的，所以在计算正负样本的时候，不需要想anchor那样计算IOU，fovea直接将ground-truth映射到对应level的特征图上，公式如下：</p>
<p><img src="/3.png" alt="3.png"></p>
<p>另外，在Fovea中，并不是ground-truth对应的区域均是正样本，如下图所示，狗虽然很大，但是真正的正样本，是中间红色区域部分，这也是fovea的精华，这里作者引入了个$\sigma$参数，可以根据参数，动态设置正样本范围。</p>
<p><img src="/4.png" alt="4.png"></p>
<p><img src="/2.png" alt="2.png"></p>
<p>至于负样本，作者在上面公式中，设置$\sigma_{2}$,在$\sigma_{2}$之外的数据均为负样本，在作者的实验中$\sigma_{1}=0.3$，$\sigma_{2}=0.4$，位于0.3-0.4之间的区域就不参与训练了。<strong>由于仍然存在正负样本不均的情况，所以作者在训练分类的时候仍然采用了Focal Loss。</strong></p>
<h4 id="Box-Prediction"><a href="#Box-Prediction" class="headerlink" title="Box Prediction"></a>Box Prediction</h4><p>在坐标预测上，FoveaBox中，在坐标预测方面，主要是通过学习了transformation函数来进行坐标的变换，如下，其中$z=\sqrt{S_{l}}$,x1等是Ground Truth,t代表网络输出，这里作者使用的是Smooth L1 loss作为计算坐标的loss函数。</p>
<p><img src="/5.png" alt="5.png"></p>
<h4 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h4><p>在inference的时候，首先使用阈值0.05，直接过滤掉不靠谱的点，然后在剩下的点中，选取得分排名前1000的点作为候选点，再然后，使用非极大值抑制，对这1000个点再次进行过滤，最后留下的top100个点作为最终的结果。</p>
<h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><h4 id="Various-anchor-densities-and-FoveaBox"><a href="#Various-anchor-densities-and-FoveaBox" class="headerlink" title="Various anchor densities and FoveaBox"></a>Various anchor densities and FoveaBox</h4><p>首先，anchor-based网络，一般跟anchor的选取有很大关系，那么fovea是不是比anchor-based方法更好呢？作者进行了实验，结果如下。可以发现，foveaBox比RetinaNet高的不是一点点。</p>
<p><img src="/6.png" alt="6.png"></p>
<h4 id="Analysis-of-Scale-Assignment"><a href="#Analysis-of-Scale-Assignment" class="headerlink" title="Analysis of Scale Assignment"></a>Analysis of Scale Assignment</h4><p>$\eta$控制着金字塔网络不同level的scale，到底选多少最为合适呢？下面的实验说明选择2是最为合适的。</p>
<p><img src="/7.png" alt="7.png"></p>
<h4 id="Fovea对于box是不是更鲁棒一些呢？"><a href="#Fovea对于box是不是更鲁棒一些呢？" class="headerlink" title="Fovea对于box是不是更鲁棒一些呢？"></a>Fovea对于box是不是更鲁棒一些呢？</h4><p>为此作者进行了实验，通过修改验证集的长宽比等。</p>
<p><img src="/8.png" alt="8.png"></p>
<h4 id="每个类别的差异"><a href="#每个类别的差异" class="headerlink" title="每个类别的差异"></a>每个类别的差异</h4><p>可见，大部分类别的效果都提升了。</p>
<p><img src="/9.png" alt="9.png"></p>
<h4 id="Fovea当做RPN效果"><a href="#Fovea当做RPN效果" class="headerlink" title="Fovea当做RPN效果"></a>Fovea当做RPN效果</h4><p>如果采用FoveaBox方式提取RPN效果如何呢？实验证明，效果要好于基于anchor的方法。</p>
<p><img src="/10.png" alt="10.png"></p>
<h4 id="不同尺度与深度的Fovea效果对比"><a href="#不同尺度与深度的Fovea效果对比" class="headerlink" title="不同尺度与深度的Fovea效果对比"></a>不同尺度与深度的Fovea效果对比</h4><p>foveaBox效果还是不错的。</p>
<p><img src="/11.png" alt="11.png"></p>
<p><img src="/12.png" alt="12.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文章整体来看，跟FCOS很像，思路基本一样，都是基于RetinaNet,同样是每一个location预测一个类别和四个坐标相关的数，只是FCOS预测到四个边界的距离，Fovea预测一个坐标转换。再有一个就是FCOS以gt boxes中的全部像素作为正例，而Fovea是采样了一个portion。其他关于FPN尺度分配的问题都是大差不差。</p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/01/foveabox/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/28/rfbnet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/28/rfbnet/" class="post-title-link" itemprop="url">RFBNet</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-28 06:11:05 / 修改时间：11:16:24" itemprop="dateCreated datePublished" datetime="2019-12-28T06:11:05+08:00">2019-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Detection/" itemprop="url" rel="index">
                    <span itemprop="name">Detection</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/28/rfbnet/" class="post-meta-item leancloud_visitors" data-flag-title="RFBNet" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/28/rfbnet/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/28/rfbnet/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>RFBNet是ECCV2018的一篇文章，文章的主要创新点在于通过Inception结构以及dilated conv模拟了人类的视觉结构—越往外视觉感受野也越大，提出了RFB结构，并将RFB结构应用于SSD结构上，实现了在不增加过多计算量的情况下模型效果的提升。</p>
</blockquote>
<hr>
<p>作者： Songtao Liu, Di Huang, Yunhong Wang</p>
<p>论文链接： <a target="_blank" rel="noopener" href="https://eccv2018.org/openaccess/content_ECCV_2018/papers/Songtao_Liu_Receptive_Field_Block_ECCV_2018_paper.pdf">RFBNet论文</a></p>
<p>代码链接： <a target="_blank" rel="noopener" href="https://github.com/ruinmessi/RFBNet">https://github.com/ruinmessi/RFBNet</a></p>
<hr>
<h3 id="RFB背景"><a href="#RFB背景" class="headerlink" title="RFB背景"></a>RFB背景</h3><p>我们说为什么深度学习的效果会比其他的机器学习方法要好，关键点在于CNN的表征能力比较强，而往往越深的网络，表征能力也越强，带来的也是更多的计算量，更慢的速度。所以要达到速度快，精度高的目标，就需要我们在轻量级网络中，通过设计某种方法，提高网络的特征表征能力。本文作者的灵感来源于人类的视觉系统，在人类的视觉系统中，往往离中心比较近的地方，感受野会比较小，而比较远的地方，感受野会比较大，借鉴于此，本文就引入了RFB结构，达到了这个目标。</p>
<p>在人类视觉系统中，视觉感受野是一个视网膜离心率的函数,下图表示了离心率与感受野尺寸的示意图，可见，离心率越大，尺寸也越大。</p>
<p><img src="/1.png" alt="1.png"></p>
<p>反观，我们现在的CNN网络，感受野基本都是一致的，这就会带来一定的特征的损失。</p>
<p>Inception block虽然使用了多个分支，构造了不同感受野，但是其融合的时候是以相同的中心进行融合的，ASPP网络，选择使用dilated conv实现了相同中心，不同距离的采样，但是感受野是一致的，如下图所示。</p>
<p><img src="/3.png" alt="3.png"></p>
<p>其实，RFBNet就是将Inception和ASPP进行了融合，达到更好的效果。如下图所示，使用空洞卷积来控制离心率，得到不同的感受野大小。通过这张图的方式得到右下角的感受野是不是就和右上角的人类视觉系统很像了呢。</p>
<p><img src="/2.png" alt="2.png"></p>
<p><strong>总结来看，RFB Block实际上就是两个部分</strong></p>
<ul>
<li>多分支的卷积</li>
<li>dilated conv或者dilated pool</li>
</ul>
<p>下图是作者设计的两种RFB结构，看图就很简单了，一目了然。（a）是比较普通版，（b）实际上就是参考inception进行升级版。rate代表的是dilated，rate=3代表dilated=3,最后的结果使用concat拼接到一起。</p>
<p><img src="/4.png" alt="4.png"></p>
<h3 id="RFB-in-Detection"><a href="#RFB-in-Detection" class="headerlink" title="RFB in Detection"></a>RFB in Detection</h3><p>如下，便是作者在SSD-300进行的修改，其实主要做的东西就是将一部分卷积替换成了RFB结构，如下图已经很清晰了，不需要再详述了，注意观察RFB那几个框，作者不仅仅在分类检测分支使用了RFB，在主干也同样使用了RFB。</p>
<p><img src="/5.png" alt="5.png"></p>
<h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><p>作者在VOC上进行的实验</p>
<ul>
<li>warmup 5个epoch</li>
</ul>
<p><img src="/6.png" alt="6.png"></p>
<p>实验解析</p>
<ul>
<li>其实从第一个实验RFB-max pooling已经显现出RFB的效果了。</li>
</ul>
<p><img src="/7.png" alt="7.png"></p>
<p>与其他网络结构的对比</p>
<ul>
<li>这里作者调整了网络结构，使得不同的网络参数量基本一致。</li>
</ul>
<p><img src="/8.png" alt="8.png"></p>
<p>在COCO的实验结果：</p>
<p><img src="/9.png" alt="9.png"></p>
<p>速度精度对比的一个图</p>
<p><img src="/10.png" alt="10.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来看，RFBNet的思想很简单，但是很新颖，并没有增加过多的东西，但是取得的效果还是很不错的，达到了一个速度与精度的平衡。</p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/28/rfbnet/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/25/consitent-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/consitent-optimization/" class="post-title-link" itemprop="url">Consistent Optimization for Single-Shot Object Detection - 你的anchor用对了吗</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 09:01:26" itemprop="dateCreated datePublished" datetime="2019-12-25T09:01:26+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 13:55:08" itemprop="dateModified" datetime="2020-01-16T13:55:08+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Detection/" itemprop="url" rel="index">
                    <span itemprop="name">Detection</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/25/consitent-optimization/" class="post-meta-item leancloud_visitors" data-flag-title="Consistent Optimization for Single-Shot Object Detection - 你的anchor用对了吗" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/25/consitent-optimization/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/consitent-optimization/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>本篇论文中，作者提出在one stage目标检测中影响网络精度的一个原因在于<strong>优化的目标与inference设置的不一致性（misalignment between the optimization target and inference configurations），解释来说就是，现在流行的目标检测方法，一般会有两个分支，一个分类，一个坐标框回归，而这两个分支往往是独立的，都是对原始anchor进行处理，这就会带来一个问题，我们在进行分类的时候，使用的是原始的anchor，而在坐标框回归后，很可能回归后的anchor与原始anchor已经产生了不同，这样使用原始anchor的分类结果作为回归后的anchor的分类得分就不准确了</strong>，本篇论文就是围绕着解决这个问题来进行的。乍一看本篇文章，感觉与Cascade RCNN有点像，采用的方法同样是对网络输出的结果进行refine，来达到提升网络精度的效果，但是其出发点是不同的，<a target="_blank" rel="noopener" href="https://blog.csdn.net/Chunfengyanyulove/article/details/86414810">Cascade R-CNN</a>的出发点是解决IOU阈值的设置带来的噪声问题，而consistent optimization的出发点是解决分类anchor与回归后的anchor不一致的问题。并且<strong>consistent optimization方法只是修改了RetinaNet网络的loss，改动不大，整体上时间消耗也没有增加，原则上说，其也不算是cascade方法，只是思想相近而已，但是本方法的实用性还是很强的。</strong></p>
</blockquote>
<hr>
<p><strong>论文名称:Consistent Optimization for Single-Shot Object Detection</strong></p>
<p><strong>作者：Tao Kong &amp; fuchun Sun &amp; Huaping Liu &amp; Yuning Jiang &amp; Jianbo Shi</strong></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1901.06563"><strong>论文链接</strong>：https://arxiv.org/abs/1901.06563</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55416312"><strong>作者解读</strong>：https://zhuanlan.zhihu.com/p/55416312</a></p>
<hr>
<p><strong>如果出现图像或者公式显示不完整，请访问本人CSDN博客</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Chunfengyanyulove/article/details/86708549"><strong>CSDN博客地址：https://blog.csdn.net/Chunfengyanyulove/article/details/86708549</strong></a></p>
<hr>
<p><strong>先上一张图，下图为论文中提供的RetinaNet加入了Consistent Optimization之后的效果，在COCO数据集上，AP平均提高1个百分点，很稳，也说明了本文方法的有效性，下面一起来学习一下这篇文章吧。</strong></p>
<p><img src="/1.png"></p>
<hr>
<h4 id="文章详细解析"><a href="#文章详细解析" class="headerlink" title="文章详细解析"></a>文章详细解析</h4><p>首先，为了证明存在上面提到的不一致性的问题，作者进行了实验分析，分析结果如下图Figure 3,可以发现，Input IOU在[0.3,0.5]之间的anchor,经过回归之后，已经变到[0.5,0.85]，而在网络训练的时候，IOU在0.4以下是被当做负样本的，显然，强行将anchor的分类得分代表坐标回归后的anchor的得分是有问题的。</p>
<p><img src="/2.png"></p>
<p>另外论文中，作者指出，<strong>当两个目标交叉在一起的时候，回归器容易产生疑惑</strong>。如下图Figure2所示，红框和黄框对应的类别都是bicycle，但是由于人与自行车交叠在一起，黄框在进行回归的时候，容易误回归到人，但如果它的分类标签还是自行车的话，就可能出现问题，如Figure2(b)所示，结果黄框的score比红框还高，这就容易导致红框在NMS的时候被干掉了，影响了目标检测的精度。</p>
<p><img src="/3.png"></p>
<p>另外作者同时分析了在RetinaNet上面对于不同的IOU的output，输出的平均的score及其方差，以及输出的output IOU的均值及其方差，实验结果如下图Figure 5所示，根据实验结果可以发现output的IOU与output score是呈正相关的，但是图（b）显示，随着Output IOU的增大，其标准差也在增长，这说明检测器对于负样本更加的鲁棒，对正样本波动比较大，但是我们希望其对正样本也具有更强的稳定性，红线是采用的consistent方法的结果，虽然没有完全解决问题，但是明显效果要好一些，符合我们的预期。</p>
<p><img src="/4.png"></p>
<p><strong>说了这么多consistent的效果，你一定很想知道consistent到底是怎么做的，下面我们就来详细学习一下。</strong></p>
<p><strong>其实，解决方法也很简单，既然anchor进行坐标框回归之后，与原来的anchor相差较大，那么我们直接对回归后的坐标框再进行一次处理就可以了。</strong></p>
<p>这样做的可选的方案其实还不少呢，如下图Figure4所示，其中图（b）是cascade rcnn的方式，图（c）是cascade rcnn的变体，图（d）是作者设计的consistent optimization结构，都可以达到目的。</p>
<p><img src="/5.png"></p>
<p>这里先说一下作者的结构（肯定这个是最好的），在作者设计的结构中，并没有增加额外的head，不增加额外的计算，仅仅是在原有的模型基础上，修改了网络的loss,将回归后的anchor与其更新后的ground truth的loss也加入到网络的loss中。</p>
<p>分类loss修改如下，i代表的是anchor的index，ci代表的是预测的概率，ci*代表的是代表的是原anchor对应的ground truth，ci+代表的是refined anchor对应的ground truth。<strong>并且作者指出，其实只使用refined anchor来训练网络已经可以得到更好的表现了，组合这两个loss一起，可以使得训练的结果更加的稳定</strong></p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=L_{cls}=\frac{1}{N_{cls}}=&amp;space;\sum_{i}[L_{cls}(ci,ci*)+aL_{cls}(ci,ci+)]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?L_{cls}=\frac{1}{N_{cls}}=&amp;space;\sum_{i}[L_{cls}(ci,ci*)+aL_{cls}(ci,ci+)]" title="L_{cls}=\frac{1}{N_{cls}}= \sum_{i}[L_{cls}(ci,ci*)+aL_{cls}(ci,ci+)]"></a></p>
<p>为了保持与分类的一致性，检测的loss修改如下:其中ti0是原始anchor输出的offset，ti1是refined anchor的输出offset,ti*$和ti+分别是其对应的ground truth</p>
<p><a href="https://www.codecogs.com/eqnedit.php?latex=L_{reg}=\frac{1}{N^0_{reg}}=&amp;space;\sum_{i}[L^0_{reg}(t_i^0,t_i^*)+&amp;space;\sum_{i}&amp;space;L^1_{reg}(t_i^1,t_i^+)]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?L_{reg}=\frac{1}{N^0_{reg}}=&amp;space;\sum_{i}[L^0_{reg}(t_i^0,t_i^*)+&amp;space;\sum_{i}&amp;space;L^1_{reg}(t_i^1,t_i^+)]" title="L_{reg}=\frac{1}{N^0_{reg}}= \sum_{i}[L^0_{reg}(t_i^0,t_i^*)+ \sum_{i} L^1_{reg}(t_i^1,t_i^+)]"></a></p>
<p><strong>讲到这你可能还不是特别理解网络到底是怎么做的，我在详细讲一下，最简单的方法，我们将优化后的anchor的gt交给分类，然后利用上面的分类loss进行训练，作者说明，这个方法是有效的，这个应该理解，再进一步的，就是作者推荐的，不仅仅是将优化后的anchor交给分类，坐标回归也同样进行两次，即在第一次回归的基础上，再进行一次回归（我猜想这就可以解决前面提到的第二个问题，容易产生混淆的问题），最终给出结果，至于怎么回归两次，其实就是在倒数第二层输出回归offset的时候，多输出4个offset，作为第二次的结果，而这4个的gt是第一次优化后anchor重新求的gt。</strong></p>
<p><strong>为什么最终作者选择了那个结构呢？主要原因还在于，这个结构的效果在这几个中是最好的。</strong></p>
<hr>
<h4 id="更多的实验分析"><a href="#更多的实验分析" class="headerlink" title="更多的实验分析"></a>更多的实验分析</h4><ul>
<li><strong>不同设计结构的效果对比</strong></li>
</ul>
<p>观察表1可以发现，使用cascade方式，虽然加入了更多的参数以及计算量，但是并没有增加AP，相反作者这种没有增加计算量的方法却取得了较好的效果。</p>
<p><strong>这个实验也说明了，效果的改善并不是因为更多的参数或者结构的设计，而是如何能将训练器训练的更好</strong></p>
<p><strong>并且对于，Cascade RCNN这种级联的方式，在two stage方法中，在anchor调整了之后，可以利用RoiPooling方式对目标区域重新提取特征，具有一定的效果，但是在one stage方法中，由于是采用卷积来联系起anchor与其gt，在anchor调整了之后，仍然是利用卷积去提取特征，只是gt做了修改而已，这样效果其实是有限的，网络较难学习到其内在的变换</strong></p>
<p><img src="/6.png"></p>
<ul>
<li><strong>那是不是可以多refined几次，stage是不是越多越有效呢？</strong></li>
</ul>
<p>作者同样进行了实验，如下：在实验中，作者分别对比了不同stage下的模型效果，并且对不同的stage，设置了不同的IOU阈值，第二个stage的正负样本IOU阈值分别为0.6，0.5，第三个stage的正负样本阈值分别为0.7，0.6，实验结果如下表，第一行是baseline,第二行是进行两次的classification，可以发现，效果提升了大约0.8个百分点，实验结果发现，进行2次分类加2次回归的实验效果是最好的，进一步增加stage，下过反而下降了，并且第三行结果显示（第三行带星号，代表的是inference时候只进行一次的回归），结果仍然提升了大约1个点，进一步说明了算法的有效性。</p>
<p><img src="/7.png"></p>
<p>作者同样对比了对于不同输入尺度的模型效果，结果如下表：<br>可以发现，<strong>在使用了consistent optimization之后，基本上AP可以提高一个百分点左右，增大图像的尺度还是有效果的，图像大小从500增加到800之后，平均可以提高3个点左右。并且对比下图使用consistent的结果可以发现，对于大图的精度的提升是最明显的（$AP_L$平均提升了约3个百分点）。</strong></p>
<p><img src="/8.png"></p>
<p>为了进一步证明consistent方法的泛化效果，作者在SSD上面进行了实验，实验结果如下，结果是令人满意的：</p>
<p><img src="/9.png"></p>
<p>与目前的state-of-the-art网络的对比，结果显示，ConRetinaNet还是很有优势的。<strong>这里的ConRetinaNet训练的时候使用了尺度的变化</strong>。加星的为使用过多预处理的技巧结果。</p>
<p>另外ConRetinaNet的精度比Cascade R-CNN以及基于Deformable ConvNet的Faster R-CNN的效果差一点，困难在哪呢？也许Cascade RCNN就是因为可以在修改了anchor之后提取对应的feature，而Deformable ConvNet则很好的学习了物体的几何变换，不过，他们的参数也比ConRetinaNet要多一些吧。</p>
<p><img src="/10.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章主要总结了在目标检测中，回归后的anchor与分类的anchor会产生不一致的问题，并在此基础上设计了consistent优化，其想法其实是很简单的，实验结果也比较不错，总体的思想还是对anchor进行进一步优化，只是采用了与cascade rcnn不同的方式，本文采用了更简单的方法实现，并在在结尾作者也说了，要想进一步提高，其实引入region-based方法的anchor效果应该更好，不过那也就不是one-stage了。</p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/25/consitent-optimization/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/25/mxnet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/mxnet/" class="post-title-link" itemprop="url">MXNet</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 08:59:23" itemprop="dateCreated datePublished" datetime="2019-12-25T08:59:23+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 13:48:14" itemprop="dateModified" datetime="2020-01-16T13:48:14+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/25/mxnet/" class="post-meta-item leancloud_visitors" data-flag-title="MXNet" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/25/mxnet/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/mxnet/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>自己使用时候总结的MXNet一些基本操作及介绍,深度学习训练框架MXNet的基本操作都在这里了</p>
</blockquote>
<h3 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h3><h4 id="NDArray介绍篇"><a href="#NDArray介绍篇" class="headerlink" title="NDArray介绍篇"></a>NDArray介绍篇</h4><p>在mxnet中，<strong>NDArray是所有运算的核心数据结构，mxnet中的所有数据均使用NDArray进行表示</strong>，NDarray有点类似于numpy中的ndarray，操作上面也与numpy很相似，但是NDArray提供了numpy.ndarray所不具备的操作，比如:<strong>GPU,CPU的切换，自动求梯度的运算等等</strong>，这也是为什么mxnet要重新封装一个NDArray的原因。</p>
<p>NDArray就好比盖房子的砖，砖有了自然可以盖房子了，所以利用NDArray你便可以实现所有的深度学习模型了，只是深度学习日新月异，如果每个模型都从NDArray开始写，那当然是比较麻烦的，所以MXnet或者gluon帮我们封装了一些函数可以直接使用，接下来我们都会逐一的了解，那么这一节我们先来仔细学习一下mxnet的NDArray：</p>
<p><strong>特别说明：下面的操作只是NDArray的一些基本操作，<br>获取更多的操作还请查找MXNet文档：<a target="_blank" rel="noopener" href="https://mxnet.incubator.apache.org/api/python/ndarray/ndarray.html">https://mxnet.incubator.apache.org/api/python/ndarray/ndarray.html</a></strong></p>
<p>==<strong>当然，我希望你可以跟我一起来敲如下的代码而不是看一遍就过去了，事实证明，敲一遍的效果会好很多</strong>==</p>
<p>在mxnet中，使用NDArray需要引用nd包(nd是ndarray的缩写)，如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br></pre></td></tr></tbody></table></figure>
<p>在引入nd包之后就可以愉快的使用NDArry了。</p>
<p><em>特别说明，下面代码中 ‘-&gt;’ 代表的是输出结果</em></p>
<p><strong>1. 定义x为一个序列，这里与numpy一致，不同的是，这里返回的每个元素类型都是ndarray</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = nd.arange(<span class="number">12</span>)   -&gt; [<span class="number">0.</span> <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span> <span class="number">7.</span> <span class="number">8.</span> <span class="number">9.</span> <span class="number">10.</span> <span class="number">11.</span>]</span><br></pre></td></tr></tbody></table></figure>


<p><strong>2. 当然我们可以打印出ndarray的shape以及size,这里的shape和size不要混淆了</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x.shape      -&gt;  (<span class="number">12</span> ,)</span><br><span class="line">x.size       -&gt;  <span class="number">12</span></span><br><span class="line">x.context    -&gt; x在CPU还是在GPU上</span><br><span class="line"></span><br><span class="line">x.dtype      -&gt; data <span class="built_in">type</span>,即每个元素的类型</span><br><span class="line"><span class="comment">## 当然，我们也可以改变元素的类型</span></span><br><span class="line">x = x.astype(‘float32’) <span class="comment">## 利用astype便可以改变元素的类型了。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong>3. 那么如果我们想要构建一个二维矩阵怎么办呢？可以考虑reshape函数</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = nd.arange(<span class="number">12</span>)</span><br><span class="line">x.reshape(shape=(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 当然你同样可以省略shape参数，直接这样写：</span></span><br><span class="line">x.reshape((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">## 不过不要忘记（3，4）这个括号</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>4. 如果我们想初始化一个值为0或者值为1的多维矩阵该怎么做呢？</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zero = nd.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))  <span class="comment"># 别忘记了是负数</span></span><br><span class="line">one = nd.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure>
<p><strong>5. 那如何建立一个随机初始化的矩阵呢？</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = nd.random.normal(<span class="number">0</span>,<span class="number">1</span>,shape=(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># normal是高斯分布</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>6. 当然我们也可以直接利用list直接建立ndarray，如下：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = nd.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br></pre></td></tr></tbody></table></figure>

<p><strong>7. 在计算机视觉中，图像一般是3维的，但是在进行模型训练的时候，往往需要将多张图像组成一个batch，构成4维数组，ndarray当然支持,使用concat：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=nd.random.normal(shape=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))   -&gt;    x.shape (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">y=nd.random.normal(shape=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))   -&gt;    y.shape (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">z=nd.concat(x,y,dim=<span class="number">0</span>)              -&gt;    z.shape (<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 因为concat是不改变维度的，那么如果构建一个batch呢？利用expand_dims函数</span></span><br><span class="line">x = nd.expand_dims(x, axis=<span class="number">0</span>)      -&gt;     x.shape (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) </span><br><span class="line">y = nd.expand_dims(y, axis=<span class="number">0</span>)      -&gt;     y.shape (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">z=nd.concat(x,y,dim=<span class="number">0</span>)             -&gt;     z.shape (<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure>


<p><strong>8. ndarray天然支持常用的数学计算，==这里方法较多，可以查阅文档，里面有例子，使用会比较方便==</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S*Y</span><br><span class="line">S/Y</span><br><span class="line">S.exp()</span><br><span class="line">S == Y</span><br><span class="line">nd.dot(S,Y.T) <span class="comment">## 点乘比较常用，深度学习中矩阵计算就是使用的点乘，如果你从头编写神经网络，一定离不开点乘</span></span><br><span class="line">nd.floor(S) <span class="comment">## 向下取整</span></span><br><span class="line">nd.ceil(S) <span class="comment">## 向上取整</span></span><br><span class="line">nd.argmax() <span class="comment">## 返回最大值的index</span></span><br><span class="line">nd.topk() <span class="comment">## 返回topk</span></span><br></pre></td></tr></tbody></table></figure>


<p><strong>9. ndarray与numpy的相互转换</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndarray -&gt; numpy</span></span><br><span class="line"></span><br><span class="line">C = S.asnumpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy -&gt; ndarray</span></span><br><span class="line"></span><br><span class="line">p = np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">d = nd.array(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的，我们也可以直接返回一个标量</span></span><br><span class="line">x = nd.ones((<span class="number">1</span>,), dtype=<span class="string">'int32'</span>)</span><br><span class="line">y = x.asscalar() <span class="comment">## 这里注意，必须是1维的才可以使用，二维会报错。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p><strong>10. 前面我们说了，NDArray可以自动计算梯度，那么如何使用呢？</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 引用包   ：<span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd</span><br><span class="line"><span class="number">2.</span> 定义变量 : x = nd.arange(<span class="number">4</span>).reshape((<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line"><span class="number">3.</span> 关联梯度，默认变量是不为梯度在内存开空间的，如果想要计算梯度，需要进行梯度关联，这样程序才会在内存上为变量开梯度的空间，如下：</span><br><span class="line">x.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 计算的时候，使用autograd.record()记录梯度，如下是点乘的计算。</span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = <span class="number">2</span> * nd.dot(x.T,x)</span><br><span class="line"><span class="number">5.</span> 使用backward()计算梯度： y.backward()</span><br><span class="line"></span><br><span class="line">总结到一起就是如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd</span><br><span class="line">x = nd.arange(<span class="number">4</span>).reshape((<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line">x.attach_grad()</span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = <span class="number">2</span> * nd.dot(x.T,x)</span><br><span class="line">y.backward()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>11. 关于CPU与GPU的切换</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = nd.random.normal(shape=(<span class="number">3</span>,<span class="number">4</span>))  <span class="comment">## 默认在CPU内存中</span></span><br><span class="line">y = nd.random.normal(shape=(<span class="number">3</span>,<span class="number">4</span>), ctx=mx.gpu(<span class="number">0</span>)) <span class="comment">## 利用ctx指定对应的GPU</span></span><br><span class="line">x = x.as_in_context(mx.gpu(<span class="number">0</span>)) <span class="comment">## 利用as_in_context进行CPU到GPU的切换</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>12. 复制也是常用的操作，利用copy（）可以避免浅拷贝的尴尬</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = nd.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y = x.copy()</span><br><span class="line"><span class="comment">## 为什么要使用copy()呢?因为在python中，默认的copy是浅拷贝，如果直接y=x,当x改变的时候，y会跟着改变，这就会出现错误。</span></span><br></pre></td></tr></tbody></table></figure>



<p><strong>特别说明：之上只是NDArray的一些基本操作，<br>获取更多的操作还请查找MXNet文档<a target="_blank" rel="noopener" href="https://mxnet.incubator.apache.org/">https://mxnet.incubator.apache.org/</a></strong></p>
<h4 id="Symbol介绍篇"><a href="#Symbol介绍篇" class="headerlink" title="Symbol介绍篇"></a>Symbol介绍篇</h4><p>Symbol的基本函数</p>
<ul>
<li>Symbol.infer_type</li>
<li>Symbol.infer_shape</li>
<li>Symbol.list_arguments</li>
<li>Symbol.list_outputs</li>
<li>Symbol.list_auxiliary_states</li>
</ul>
<p>args = 输入数据symbol + 权值参数symbol</p>
<p>aux = 辅助symbol，比如bn中的mean以及var</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = mx.sym.var(<span class="string">'data'</span>)</span><br><span class="line">fc = mx.sym.FullyConnected(data=data, num_hidden=<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'name:'</span>, fc.list_arguments(), fc.list_outputs(), fc.list_auxiliary_statues())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'type:'</span>, fc.infer_type(data=(np.float32,np.float32)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'shape：'</span>， fc.infer_shape(data=(<span class="number">1</span>,<span class="number">2</span>)）)</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data= mx.sym.var(<span class="string">'data'</span>, shape=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">weight= mx.sym.var(<span class="string">'data'</span>, shape=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">bias= mx.sym.var(<span class="string">'data'</span>, shape=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">fc = mx.sym.FullyConnected(data=data, weight=weight, bias=bias, num_hidden=<span class="number">12</span>)</span><br><span class="line">executor = fc.bind(ctx=mx.cpu(), args={<span class="string">'data'</span>:mx.nd.ones([<span class="number">1</span>,<span class="number">2</span>]),<span class="string">'weight'</span>:mx.nd.normal(shape=(<span class="number">12</span>,<span class="number">2</span>),<span class="string">'bias'</span>:mx.nd.random.normal(shape=(<span class="number">12</span>,)))})</span><br><span class="line">executor.forward()</span><br><span class="line"><span class="built_in">print</span>(executor.outputs[<span class="number">0</span>].asnumpy())</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = mx.sym.var(<span class="string">'data'</span>)</span><br><span class="line">fc = mx.sym.FullyConnected(data=data, num_hidden=<span class="number">12</span>)</span><br><span class="line">fc2 = mx.sym.FullyConnected(data=fc, num_hidden=<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(fc2.get_internals().list_outputs())  <span class="comment">## 可以轻松获得任何一个节点</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Module介绍篇"><a href="#Module介绍篇" class="headerlink" title="Module介绍篇"></a>Module介绍篇</h4><ul>
<li>Module是MXNet中集成的接口，将几乎所有的模块封装成一个可以一步完成的训练和测试接口。</li>
<li>所有的Module均继承了BaseModule</li>
</ul>
<h4 id="Metric-介绍篇"><a href="#Metric-介绍篇" class="headerlink" title="Metric 介绍篇"></a>Metric 介绍篇</h4><ul>
<li>Metric是衡量模型效果的接口，如下是官方的计算Accuracy的例子</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accuracy</span>(<span class="title class_ inherited__">EvalMetric</span>):</span><br><span class="line">    <span class="string">"""Computes accuracy classification score.</span></span><br><span class="line"><span class="string">    Examples</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; predicts = [mx.nd.array([[0.3, 0.7], [0, 1.], [0.4, 0.6]])]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; labels   = [mx.nd.array([0, 1, 1])]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; acc = mx.metric.Accuracy()</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; acc.update(preds = predicts, labels = labels)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print acc.get()</span></span><br><span class="line"><span class="string">    ('accuracy', 0.6666666666666666)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, axis=<span class="number">1</span>, name=<span class="string">'accuracy'</span>,</span></span><br><span class="line"><span class="params">                 output_names=<span class="literal">None</span>, label_names=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Accuracy, self).__init__(</span><br><span class="line">            name, axis=axis,</span><br><span class="line">            output_names=output_names, label_names=label_names,</span><br><span class="line">            has_global_stats=<span class="literal">True</span>)</span><br><span class="line">        self.axis = axis</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, labels, preds</span>):</span><br><span class="line">        <span class="string">"""Updates the internal evaluation result.</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        labels : list of `NDArray`</span></span><br><span class="line"><span class="string">            The labels of the data with class indices as values, one per sample.</span></span><br><span class="line"><span class="string">        preds : list of `NDArray`</span></span><br><span class="line"><span class="string">            Prediction values for samples. Each prediction value can either be the class index,</span></span><br><span class="line"><span class="string">            or a vector of likelihoods for all classes.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        labels, preds = check_label_shapes(labels, preds, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> label, pred_label <span class="keyword">in</span> <span class="built_in">zip</span>(labels, preds):</span><br><span class="line">            <span class="keyword">if</span> pred_label.shape != label.shape:</span><br><span class="line">                pred_label = ndarray.argmax(pred_label, axis=self.axis)</span><br><span class="line">            pred_label = pred_label.asnumpy().astype(<span class="string">'int32'</span>)</span><br><span class="line">            label = label.asnumpy().astype(<span class="string">'int32'</span>)</span><br><span class="line">            <span class="comment"># flatten before checking shapes to avoid shape miss match</span></span><br><span class="line">            label = label.flat</span><br><span class="line">            pred_label = pred_label.flat</span><br><span class="line"></span><br><span class="line">            check_label_shapes(label, pred_label)</span><br><span class="line"></span><br><span class="line">            num_correct = (pred_label == label).<span class="built_in">sum</span>()</span><br><span class="line">            self.sum_metric += num_correct</span><br><span class="line">            self.global_sum_metric += num_correct</span><br><span class="line">            self.num_inst += <span class="built_in">len</span>(pred_label)</span><br><span class="line">            self.global_num_inst += <span class="built_in">len</span>(pred_label)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>如何实现自己的metric函数</p>
<blockquote>
<ul>
<li><p>需要继承EvalMetric，并重写update函数，注意传入参数的类型。</p>
</li>
<li><p>更新sum_metric和num_inst的值，mxnet会调用sum_metric/num_inst来计算当前metric输出值。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="二、使用篇"><a href="#二、使用篇" class="headerlink" title="二、使用篇"></a>二、使用篇</h3><h4 id="mxnet生成lst以及rec文件（mxnet指定的训练数据格式）"><a href="#mxnet生成lst以及rec文件（mxnet指定的训练数据格式）" class="headerlink" title="mxnet生成lst以及rec文件（mxnet指定的训练数据格式）"></a>mxnet生成lst以及rec文件（mxnet指定的训练数据格式）</h4><p>生成lst的时候，第一个参数是目标存放地址，第二个参数是图像文件目录，利用如下命令会生成<strong>train.lst以及val.lst</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python im2rec.py --<span class="built_in">list</span> --recursive --train-ratio <span class="number">0.95</span> /path/train  /path/train <span class="comment"># 前面的参数修改成 /path/lst/data 会生成 data_train.lst</span></span><br><span class="line">python im2rec.py --<span class="built_in">list</span> --recursive --train-ratio <span class="number">0.95</span> /path/val  /path/val</span><br><span class="line"></span><br><span class="line">python im2rec.py --force-resize <span class="number">400</span> --num-thread <span class="number">8</span> /path/train.lst /path/train</span><br><span class="line">python im2rec.py --force-resize <span class="number">400</span> --num-thread <span class="number">8</span> /path/val.lst /path/val</span><br><span class="line"></span><br><span class="line"><span class="comment">#multi-label</span></span><br><span class="line">python im2rec.py --pack-label --num-thread <span class="number">8</span> /path/train_lst.lst /path/train</span><br></pre></td></tr></tbody></table></figure>

<h4 id="mxnet训练demo"><a href="#mxnet训练demo" class="headerlink" title="mxnet训练demo"></a>mxnet训练demo</h4><h5 id="简单的利用fit直接训练"><a href="#简单的利用fit直接训练" class="headerlink" title="简单的利用fit直接训练"></a>简单的利用fit直接训练</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line">mnist = mx.test_utils.get_mnist()</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">train_iter = mx.io.NDArrayIter(mnist[<span class="string">'train_data'</span>], mnist[<span class="string">'train_label'</span>], batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">val_iter = mx.io.NDArrayIter(mnist[<span class="string">'test_data'</span>], mnist[<span class="string">'test_label'</span>], batch_size)</span><br><span class="line"></span><br><span class="line">data = mx.sym.var(<span class="string">'data'</span>)</span><br><span class="line"><span class="comment"># Flatten the data from 4-D shape into 2-D (batch_size, num_channel*width*height)</span></span><br><span class="line">data = mx.sym.flatten(data=data) <span class="comment">#需要展开，因为全连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The first fully-connected layer and the corresponding activation function</span></span><br><span class="line">fc1  = mx.sym.FullyConnected(data=data, num_hidden=<span class="number">128</span>)</span><br><span class="line">act1 = mx.sym.Activation(data=fc1, act_type=<span class="string">"relu"</span>)</span><br><span class="line">fc2  = mx.sym.FullyConnected(data=act1, num_hidden = <span class="number">64</span>)</span><br><span class="line">act2 = mx.sym.Activation(data=fc2, act_type=<span class="string">"relu"</span>)</span><br><span class="line">fc3  = mx.sym.FullyConnected(data=act2, num_hidden=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Softmax with cross entropy loss</span></span><br><span class="line">mlp  = mx.sym.SoftmaxOutput(data=fc3, name=<span class="string">'softmax'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a trainable module on CPU</span></span><br><span class="line">mlp_model = mx.mod.Module(symbol=mlp, context=mx.cpu())</span><br><span class="line">mlp_model.fit(train_iter,  <span class="comment"># train data</span></span><br><span class="line">              eval_data=val_iter,  <span class="comment"># validation data</span></span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,  <span class="comment"># use SGD to train</span></span><br><span class="line">              optimizer_params={<span class="string">'learning_rate'</span>:<span class="number">0.1</span>},  <span class="comment"># fixed learning rate</span></span><br><span class="line">              eval_metric=<span class="string">'acc'</span>,  <span class="comment"># report accuracy during training</span></span><br><span class="line">              batch_end_callback = mx.callback.Speedometer(batch_size, <span class="number">100</span>), <span class="comment"># output progress for each 100 data batches</span></span><br><span class="line">              num_epoch=<span class="number">10</span>)  <span class="comment"># train for at most 10 dataset passes</span></span><br></pre></td></tr></tbody></table></figure>




<h5 id="mxnet的训练过程，step-by-step"><a href="#mxnet的训练过程，step-by-step" class="headerlink" title="mxnet的训练过程，step by step"></a>mxnet的训练过程，step by step</h5><blockquote>
<p>训练模型主要包括下面几个step:</p>
<ul>
<li>bind : prepares environment for the computation by allocating memory</li>
<li>init_params : assigns and initializes parameters</li>
<li>init_optimizer : initializes optimizers defaults to sgd</li>
<li>metric.create : creates evaluation metric from input metric name</li>
<li>forward : forward computation </li>
<li>update_metric : evaluates and accumulates evaluation metric on outputs of the last forward computation </li>
<li>backward: backwoard computation</li>
<li>update: upadates parameters according to the installed optimizer and the gradients computed in the previous forward-backward batch</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.getLogger().setLevel(logging.INFO)</span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">fname = mx.test_utils.download(<span class="string">'http://archive.ics.uci.edu/ml/machine-learning-databases/letter-recognition/letter-recognition.data'</span>)</span><br><span class="line">data = np.genfromtxt(fname, delimiter=<span class="string">','</span>)[:,<span class="number">1</span>:]</span><br><span class="line">label = np.array([<span class="built_in">ord</span>(l.split(<span class="string">','</span>)[<span class="number">0</span>])-<span class="built_in">ord</span>(<span class="string">'A'</span>) <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">open</span>(fname, <span class="string">'r'</span>)])</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">ntrain = <span class="built_in">int</span>(data.shape[<span class="number">0</span>]*<span class="number">0.8</span>)</span><br><span class="line">train_iter = mx.io.NDArrayIter(data[:ntrain, :], label[:ntrain], batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">val_iter = mx.io.NDArrayIter(data[ntrain:, :], label[ntrain:], batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">###搭建网络</span></span><br><span class="line">net = mx.sym.Variable(<span class="string">'data'</span>)</span><br><span class="line">net = mx.sym.FullyConnected(net, name=<span class="string">'fc1'</span>, num_hidden=<span class="number">64</span>)</span><br><span class="line">net = mx.sym.Activation(net, name=<span class="string">'relu1'</span>, act_type=<span class="string">"relu"</span>)</span><br><span class="line">net = mx.sym.FullyConnected(net, name=<span class="string">'fc2'</span>, num_hidden=<span class="number">26</span>)</span><br><span class="line">net = mx.sym.SoftmaxOutput(net, name=<span class="string">'softmax'</span>)</span><br><span class="line">mx.viz.plot_network(net)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mod = mx.mod.Module(symbol=net,</span><br><span class="line">                    context=mx.cpu(),</span><br><span class="line">                    data_names=[<span class="string">'data'</span>],</span><br><span class="line">                    label_names=[<span class="string">'softmax_label'</span>])</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"><span class="comment"># allocate memory given the input data and label shapes</span></span><br><span class="line">mod.bind(data_shapes=train_iter.provide_data,label_shapes=train_iter.provide_label)</span><br><span class="line"><span class="comment"># initialize parameters by uniform random numbers</span></span><br><span class="line">mod.init_params(initializer=mx.init.Uniform(scale=<span class="number">.1</span>))</span><br><span class="line"><span class="comment"># use SGD with learning rate 0.1 to train</span></span><br><span class="line">mod.init_optimizer(optimizer=<span class="string">'sgd'</span>, optimizer_params=((<span class="string">'learning_rate'</span>, <span class="number">0.1</span>), ))</span><br><span class="line"><span class="comment"># use accuracy as the metric</span></span><br><span class="line">metric = mx.metric.create(<span class="string">'acc'</span>)</span><br><span class="line"><span class="comment"># train 5 epochs, i.e. going over the data iter one pass</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    train_iter.reset()</span><br><span class="line">    metric.reset()</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_iter:</span><br><span class="line">        mod.forward(batch, is_train=<span class="literal">True</span>)       <span class="comment"># compute predictions</span></span><br><span class="line">        mod.update_metric(metric, batch.label)  <span class="comment"># accumulate prediction accuracy</span></span><br><span class="line">        mod.backward()                          <span class="comment"># compute gradients</span></span><br><span class="line">        mod.update()                            <span class="comment"># update parameters</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Epoch %d, Training %s'</span> % (epoch, metric.get()))</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>


<h4 id="mxnet进行finetune代码示例"><a href="#mxnet进行finetune代码示例" class="headerlink" title="mxnet进行finetune代码示例"></a>mxnet进行finetune代码示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> CosineScheduler <span class="keyword">import</span> CosineScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_fine_tune_model</span>(<span class="params">sym, num_classes, layer_name, fixed_layer_name</span>):</span><br><span class="line"></span><br><span class="line">    all_layers = sym.get_internals()</span><br><span class="line">    net = all_layers[layer_name + <span class="string">'_output'</span>]</span><br><span class="line">    net = mx.symbol.FullyConnected(data=net, num_hidden=num_classes, name=<span class="string">'fc'</span>)</span><br><span class="line">    net = mx.symbol.SoftmaxOutput(data=net, name=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multi_factor_scheduler</span>(<span class="params">args, epoch_size</span>):</span><br><span class="line">    step = <span class="built_in">range</span>(args.step, args.num_epoch, args.step)</span><br><span class="line">    step_ = [epoch_size * (x - args.begin_epoch) <span class="keyword">for</span> x <span class="keyword">in</span> step <span class="keyword">if</span> x - args.begin_epoch &gt; <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> mx.lr_scheduler.MultiFactorScheduler(step=step_, factor=args.factor) <span class="keyword">if</span> <span class="built_in">len</span>(step_) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cos_scheduler</span>(<span class="params">args, epoch_size</span>):</span><br><span class="line">    epoch_steps =  epoch_size</span><br><span class="line">    total_steps = args.num_epoch * epoch_steps</span><br><span class="line">    <span class="keyword">return</span> CosineScheduler(total_steps,epoch_steps,base_lr=args.lr, final_lr = args.lr * <span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_loader</span>(<span class="params">args</span>):</span><br><span class="line">    data_shape_list = [<span class="built_in">int</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> args.image_shape.split(<span class="string">","</span>)]</span><br><span class="line">    data_shape = <span class="built_in">tuple</span>(data_shape_list)</span><br><span class="line"></span><br><span class="line">    train = mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=args.data_train,</span><br><span class="line">        label_width=<span class="number">1</span>,</span><br><span class="line">        mean_r=<span class="number">123.68</span>,</span><br><span class="line">        mean_g=<span class="number">116.779</span>,</span><br><span class="line">        mean_b=<span class="number">103.939</span>,</span><br><span class="line">        std_r=<span class="number">58.393</span>,</span><br><span class="line">        std_g=<span class="number">57.12</span>,</span><br><span class="line">        std_b=<span class="number">57.375</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        batch_size=args.batch_size,</span><br><span class="line">        rand_crop=args.random_crop,</span><br><span class="line">        rand_mirror=args.random_mirror,</span><br><span class="line">        <span class="comment"># max_aspect_ratio=args.max_aspect_ratio,</span></span><br><span class="line">        max_random_contrast=args.max_random_contrast,</span><br><span class="line">        max_random_illumination=args.max_random_illumination,</span><br><span class="line">        max_rotate_angle=args.max_rotate_angle,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        num_parts=kv.num_workers,</span><br><span class="line">        resize=args.resize_train,</span><br><span class="line">        part_index=kv.rank)</span><br><span class="line"></span><br><span class="line">    val = mx.io.ImageRecordIter(</span><br><span class="line">        path_imgrec=args.data_val,</span><br><span class="line">        label_width=<span class="number">1</span>,</span><br><span class="line">        mean_r=<span class="number">123.68</span>,</span><br><span class="line">        mean_g=<span class="number">116.779</span>,</span><br><span class="line">        mean_b=<span class="number">103.939</span>,</span><br><span class="line">        std_r=<span class="number">58.393</span>,</span><br><span class="line">        std_g=<span class="number">57.12</span>,</span><br><span class="line">        std_b=<span class="number">57.375</span>,</span><br><span class="line">        data_name=<span class="string">'data'</span>,</span><br><span class="line">        label_name=<span class="string">'softmax_label'</span>,</span><br><span class="line">        data_shape=data_shape,</span><br><span class="line">        batch_size=args.batch_size,</span><br><span class="line">        rand_crop=<span class="number">0</span>,</span><br><span class="line">        rand_mirror=<span class="number">0</span>,</span><br><span class="line">        shuffle=<span class="literal">False</span>,</span><br><span class="line">        num_parts=kv.num_workers,</span><br><span class="line">        resize=args.resize_val,</span><br><span class="line">        part_index=kv.rank)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train,val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">args, kv=<span class="string">'device'</span></span>):</span><br><span class="line">    train, val = data_loader(args)</span><br><span class="line"></span><br><span class="line">    prefix = args.model</span><br><span class="line">    sym, arg_params, aux_params = mx.model.load_checkpoint(prefix, args.begin_epoch)</span><br><span class="line">    sym = get_symbol(num_classes=args.num_classes, num_layers=<span class="number">50</span>, image_shape=<span class="string">'3,224,224'</span>, fixed_stage= args.fixed_stage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    new_sym, fix_names = get_fine_tune_model(</span><br><span class="line">        sym, args.num_classes, args.layer_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    epoch_size = <span class="built_in">max</span>(<span class="built_in">int</span>(args.num_examples / args.batch_size / kv.num_workers), <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> args.cosine == <span class="literal">True</span>:</span><br><span class="line">        lr_scheduler = cos_scheduler(args, epoch_size)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lr_scheduler = multi_factor_scheduler(args, epoch_size)</span><br><span class="line"></span><br><span class="line">    optimizer_params = {</span><br><span class="line">        <span class="string">'learning_rate'</span>: args.lr,</span><br><span class="line">        <span class="string">'momentum'</span>: args.mom,</span><br><span class="line">        <span class="string">'wd'</span>: args.wd,</span><br><span class="line">        <span class="string">'lr_scheduler'</span>: lr_scheduler}</span><br><span class="line">    initializer = mx.init.Xavier(</span><br><span class="line">        rnd_type=<span class="string">'gaussian'</span>, factor_type=<span class="string">"in"</span>, magnitude=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.gpus == <span class="string">''</span>:</span><br><span class="line">        devs = mx.cpu()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        devs = [mx.gpu(<span class="built_in">int</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> args.gpus.split(<span class="string">','</span>)]</span><br><span class="line"></span><br><span class="line">    model = mx.mod.Module(</span><br><span class="line">        context=devs,</span><br><span class="line">        symbol=new_sym,</span><br><span class="line">        label_names=[<span class="string">"softmax_label"</span>],</span><br><span class="line">        fixed_param_names = fix_names</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    checkpoint = mx.callback.do_checkpoint(args.save_result + args.save_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    eval_metric = mx.metric.CompositeEvalMetric()</span><br><span class="line">    eval_metric.add(CrossEntropy())</span><br><span class="line">    eval_metric.add(Accuracy())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">	model.fit(train_data=train,</span><br><span class="line">			  eval_data=val,</span><br><span class="line">			  begin_epoch=args.begin_epoch,</span><br><span class="line">			  num_epoch=args.num_epoch,</span><br><span class="line">			  eval_metric=eval_metric,</span><br><span class="line">			  validation_metric=eval_metric,</span><br><span class="line">			  kvstore=kv,</span><br><span class="line">			  optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">			  optimizer_params=optimizer_params,</span><br><span class="line">			  arg_params=arg_params,</span><br><span class="line">			  aux_params=aux_params,</span><br><span class="line">			  initializer=initializer,</span><br><span class="line">			  allow_missing=<span class="literal">True</span>,  <span class="comment"># for new fc layer</span></span><br><span class="line">			  batch_end_callback=mx.callback.Speedometer(args.batch_size, <span class="number">20</span>),</span><br><span class="line">			  epoch_end_callback=checkpoint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'score a model on a dataset'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--model'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'./pretrain_models/resnet50v1d-pretrained'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--gpus'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'0'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--batch-size'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--begin-epoch'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--image-shape'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'3,224,224'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--resize-train'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">256</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--resize-val'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">224</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--data-train'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'/app/data/train_filter_modify.rec'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--data-val'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'/app/data/test_filter_modify.rec'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--num-classes'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">3</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--lr'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.005</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--num-epoch'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">25</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--kv-store'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'device'</span>, <span class="built_in">help</span>=<span class="string">'the kvstore type'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--save-result'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">'the save path'</span>, default=<span class="string">'/app/output/resnext-50-test'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--num-examples'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">20000</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--mom'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.9</span>, <span class="built_in">help</span>=<span class="string">'momentum for sgd'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--wd'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0001</span>, <span class="built_in">help</span>=<span class="string">'weight decay for sgd'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--save-name'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">'the save name of model'</span>, default=<span class="string">'resnext-50'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--random-crop'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>, <span class="built_in">help</span>=<span class="string">'if or not randomly crop the image'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--random-mirror'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">'if or not randomly flip horizontally'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--max-aspect-ratio'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.3</span>, <span class="built_in">help</span>=<span class="string">'width/height'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--max_random_contrast'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.3</span>, <span class="built_in">help</span>=<span class="string">'Chanege the contrast with a value randomly chosen from [-max, max]'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--max_random_illumination'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">30</span>, <span class="built_in">help</span>=<span class="string">'Chanege the illumination with a value randomly chosen from [-max, max]'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--max_rotate_angle'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">15</span>, <span class="built_in">help</span>=<span class="string">'Rotate by a random degree in [-v,v]'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--layer-name'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'flatten0'</span>, <span class="built_in">help</span>=<span class="string">'the layer name before fullyconnected layer'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--factor'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.2</span>, <span class="built_in">help</span>=<span class="string">'factor for learning rate decay'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--step'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">5</span>, <span class="built_in">help</span>=<span class="string">'step for learning rate decay'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--cosine'</span>, <span class="built_in">type</span>=<span class="built_in">bool</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">'cosine for learning rate decay'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    kv = mx.kvstore.create(args.kv_store)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(args.save_result):</span><br><span class="line">        os.makedirs(args.save_result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create a logger and set the level</span></span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(<span class="string">'%(asctime)s - %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this handler is used to record information in train.log</span></span><br><span class="line">    hdlr = logging.FileHandler(args.save_result + <span class="string">'/train.log'</span>)</span><br><span class="line">    hdlr.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(hdlr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this handler is used to print information in terminal</span></span><br><span class="line">    console = logging.StreamHandler()</span><br><span class="line">    console.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(console)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># record the information of args</span></span><br><span class="line">    logging.info(args)</span><br><span class="line"></span><br><span class="line">    train_model(args=args, kv=kv)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="finetune的时候，如何调整新加层的学习率"><a href="#finetune的时候，如何调整新加层的学习率" class="headerlink" title="finetune的时候，如何调整新加层的学习率"></a>finetune的时候，如何调整新加层的学习率</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = mx.sym.var(<span class="string">'weight'</span>, lr_mult=<span class="number">5</span>)</span><br><span class="line">add_conv_1 = mx.sym.Convolution(data=data, weight=weight, num_filter=<span class="number">1024</span>, kernel=(<span class="number">1</span>,<span class="number">1</span>), name=<span class="string">'add_conv_1'</span>)</span><br></pre></td></tr></tbody></table></figure>


<h4 id="mxnet进行inference代码示例"><a href="#mxnet进行inference代码示例" class="headerlink" title="mxnet进行inference代码示例"></a>mxnet进行inference代码示例</h4><p><strong>这里是我自己的代码，可能不适用所有情况，需要按需修改</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_transpose</span>(<span class="params">data, augments</span>):</span><br><span class="line">    <span class="keyword">for</span> aug <span class="keyword">in</span> augments:</span><br><span class="line">	data = aug(data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img_read_aug</span>(<span class="params">path</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        img = cv2.imread(path)</span><br><span class="line">        <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        img = mx.image.imread(path)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cla_cast_aug = mx.image.CastAug()</span><br><span class="line">    cla_resize_aug = mx.image.ForceResizeAug(size=[<span class="number">224</span>, <span class="number">224</span>])</span><br><span class="line"></span><br><span class="line">    color_norm_aug = mx.image.ColorNormalizeAug(mx.nd.array([<span class="number">123.68</span>, <span class="number">116.779</span>, <span class="number">103.939</span>]), mx.nd.array([<span class="number">58.393</span>, <span class="number">57.12</span>, <span class="number">57.375</span>]))</span><br><span class="line"></span><br><span class="line">    cla_augmenters = [cla_cast_aug, cla_resize_aug, color_norm_aug]</span><br><span class="line"></span><br><span class="line">    img = data_transpose(img, cla_augmenters)</span><br><span class="line">    img = mx.nd.transpose(img, axes=(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    img = mx.nd.expand_dims(img,axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">img,mod</span>):</span><br><span class="line"></span><br><span class="line">    data_batch = mx.io.DataBatch([img])</span><br><span class="line">    mod.forward(data_batch)</span><br><span class="line">    prob = mod.get_outputs()[<span class="number">0</span>].asnumpy()</span><br><span class="line">    <span class="keyword">return</span> prob</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">model, base_path, count, recursion, base_result_path,result_anay,class_dict,outfile</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'process:{}'</span>.<span class="built_in">format</span>(base_path))</span><br><span class="line"></span><br><span class="line">    files = os.listdir(base_path)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(base_path, file)):</span><br><span class="line"></span><br><span class="line">            <span class="comment">### recursion</span></span><br><span class="line">            inference(model, os.path.join(base_path,file), count,recursion + <span class="number">1</span>, os.path.join(base_result_path,file), result_anay,class_dict,outfile)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img_path = os.path.join(base_path, file)</span><br><span class="line">            img = img_read_aug(img_path)</span><br><span class="line">            <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cla = predict(img, model)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'predict error'</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">max</span> = np.argmax(cla[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            result_name = <span class="string">'cla'</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(args.num_classes):</span><br><span class="line">                result_name += <span class="string">'-{}-{:.4f}'</span>.<span class="built_in">format</span>(class_dict[i],cla[<span class="number">0</span>][i])</span><br><span class="line"></span><br><span class="line">            result_name +=  (<span class="string">'-'</span> + file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> recursion == <span class="number">0</span>:</span><br><span class="line">                result_path = os.path.join(base_result_path,<span class="string">'-'</span> + class_dict[<span class="built_in">max</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fold_name = base_result_path.split(<span class="string">'/'</span>)[-<span class="number">1</span>]</span><br><span class="line">                result_path = os.path.join(base_result_path, fold_name + <span class="string">'-'</span> + class_dict[<span class="built_in">max</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment">### result analysis</span></span><br><span class="line">                <span class="keyword">if</span> result_anay.has_key(fold_name + <span class="string">':'</span> + class_dict[<span class="built_in">max</span>]):</span><br><span class="line">                    result_anay[fold_name + <span class="string">':'</span> + class_dict[<span class="built_in">max</span>]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result_anay[fold_name + <span class="string">':'</span> + class_dict[<span class="built_in">max</span>]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> args.save_txt == <span class="number">1</span>:</span><br><span class="line">                outfile.writelines(result_path + <span class="string">'\t'</span> + result_name + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">if</span> args.save_image == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'save-image'</span> + <span class="built_in">str</span>(args.save_image))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">                    os.makedirs(result_path)</span><br><span class="line">                shutil.copyfile(img_path, os.path.join(result_path, result_name))</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'--{}--'</span>.<span class="built_in">format</span>(count))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args</span>):</span><br><span class="line"></span><br><span class="line">    sym, arg_params, aux_params = mx.model.load_checkpoint(args.model_path, args.model_index)</span><br><span class="line">    model = mx.mod.Module(symbol=sym, context=mx.gpu(args.gpu))</span><br><span class="line">    model.bind(data_shapes=[(<span class="string">'data'</span>,(<span class="number">1</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>))], for_training=<span class="literal">False</span>)</span><br><span class="line">    model.set_params(arg_params, aux_params)</span><br><span class="line"></span><br><span class="line">    base_path = args.test_images_path</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(base_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'images file path error'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    result_path = args.test_result_path</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_path):</span><br><span class="line">        os.makedirs(result_path)</span><br><span class="line"></span><br><span class="line">    outfile = <span class="built_in">open</span>(os.path.join(result_path,<span class="string">'infer_record.txt'</span>),<span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    recursion = <span class="number">0</span></span><br><span class="line">    result_anay = {}</span><br><span class="line">    class_dict = {i:item <span class="keyword">for</span> i,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(args.class_label.strip().split(<span class="string">','</span>))}</span><br><span class="line"></span><br><span class="line">    inference(model, base_path, count, recursion, result_path,result_anay,class_dict,outfile)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(result_anay)</span><br><span class="line">    outfile.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">'score a model on a dataset'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--model-path'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">''</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--model-index'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--num-classes'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">3</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--class-label'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'porno,sexy,normal'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--test-images-path'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'None'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--test-result-path'</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">'None'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--save-image'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--save-txt'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--gpu'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>如下脚本运行上面代码</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">python ./src/inference.py \</span><br><span class="line">--gpu 1 \</span><br><span class="line">--model-path ./trainoutput/test-fixed-stage-2/porno-resnetv1d-50 \</span><br><span class="line">--model-index 16 \</span><br><span class="line">--num-classes 3 \</span><br><span class="line">--class-label porno,sexy,normal \</span><br><span class="line">--test-images-path /Data/download-data-normal   \</span><br><span class="line">--test-result-path /Data/download-data-normal-result \</span><br><span class="line">--save-image 0 \</span><br><span class="line">--save-txt 1 \</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="mxnet进行inference的时候多种方式读取图像（看你习惯哪一个）"><a href="#mxnet进行inference的时候多种方式读取图像（看你习惯哪一个）" class="headerlink" title="mxnet进行inference的时候多种方式读取图像（看你习惯哪一个）"></a>mxnet进行inference的时候多种方式读取图像（看你习惯哪一个）</h4><p>1、利用mxnet的imread()函数读取图像并进行数据扩增：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#### data augment function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">data,augmenters</span>):</span><br><span class="line">    <span class="keyword">for</span> aug <span class="keyword">in</span> augmenters:</span><br><span class="line">        data = aug(data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 常用操作</span></span><br><span class="line">cast_aug = mx.image.CastAug()</span><br><span class="line">resize_aug = mx.image.ForceResizeAug(size=[width,height])</span><br><span class="line">color_normal_aug = mx.image.ColorNormalizeAug(mx.nd.array([<span class="number">123</span>,<span class="number">117</span>,<span class="number">104</span>]),mx.nd.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]))</span><br><span class="line">argmenters = [cast_aug, resize_aug, color_normal_aug]</span><br><span class="line"></span><br><span class="line"><span class="comment">#### read image</span></span><br><span class="line">image = mx.image.imread(path)  <span class="comment">## 默认是RGB格式的，mxnet默认操作RGB格式数据</span></span><br><span class="line">image = transform(image,argmenters) <span class="comment">## mxnet默认的图像操作在channel_last进行</span></span><br><span class="line">image = mx.nd.transpose(image,axes=()==(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">image = mx.nd.expand_dims(image,axis=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>2、另一种mxnet图像读取方式：利用数据流：</p>
<p><strong>这时，data是ndarray格式的数据(imdecode进行图像解码)</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image_string = open('file_path', 'rb').read()</span><br><span class="line">data = mx.image.imdecode(image_string, flag=1)</span><br><span class="line">data = mx.nd.transpose(data,axes=(2, 0, 1))</span><br><span class="line">data = mx.nd.expand_dims(data, axis=0)</span><br><span class="line">print('shape:{}'.format(data.shape))</span><br></pre></td></tr></tbody></table></figure>

<p>3、采用opencv读取方式进行图像操作</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readImage</span>(<span class="params">path</span>):</span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="built_in">print</span> <span class="string">'xxx'</span></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line">    img= np.transpose(img,(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">## channel first</span></span><br><span class="line">    img = img[np.newaxis,:] <span class="comment">## add batch -&gt; 4 dims</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
<p>==<strong>mxnet对于读取的图像类型有局限性，非jpe或者jpeg图像容易出现错误</strong>==</p>
<h3 id="三、使用升级篇"><a href="#三、使用升级篇" class="headerlink" title="三、使用升级篇"></a>三、使用升级篇</h3><h4 id="mxnet如何获取网络参数"><a href="#mxnet如何获取网络参数" class="headerlink" title="mxnet如何获取网络参数"></a>mxnet如何获取网络参数</h4><p><strong>mxnet可以通过model.get_params() 可以得到arg_params以及aux_params</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line">sym, arg_params, aux_params = mx.model.load_checkpoint(<span class="string">'resnet-50'</span>,<span class="number">0</span>)<span class="comment">#载入模型</span></span><br><span class="line">mod = mx.mod.Module(symbol=sym,context=mx.gpu(<span class="number">0</span>)) <span class="comment">#创建Module</span></span><br><span class="line">mod.bind(for_training=<span class="literal">False</span>,data_shapes=[(<span class="string">'data'</span>,(<span class="number">1</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>))]) </span><br><span class="line">mod.set_params(arg_params,aux_params)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">filename</span>):</span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="built_in">print</span> <span class="string">'xxx'</span></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) <span class="comment">## BGR - &gt; RGB</span></span><br><span class="line">    img= np.transpose(img,(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">## channel first</span></span><br><span class="line">    img = img[np.newaxis,:] <span class="comment">## add batch -&gt; 4 dims</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Batch = namedtuple(<span class="string">'Batch'</span>,[<span class="string">'data'</span>])</span><br><span class="line">img = get_image(<span class="string">'val_1000/0.jpg'</span>) <span class="comment">#获取图片</span></span><br><span class="line">data_batch = Batch([mx.nd.array(img)]) </span><br><span class="line">mod.forward(data_batch) <span class="comment">#预测结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"><span class="comment">#获取权重信息</span></span><br><span class="line">keys = mod.get_params()[<span class="number">0</span>].keys() <span class="comment"># 列出所有权重名称</span></span><br><span class="line">conv_w = mod.get_params()[<span class="number">0</span>][<span class="string">'conv0_weight'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法二：直接从读取的arg_params读取，这个本身就是key，value结构。</span></span><br><span class="line">fc_weight = arg_params[<span class="string">'fc_weight'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取想要查看的权重信息,如conv_weight</span></span><br><span class="line"><span class="built_in">print</span> conv_w.asnumpy() <span class="comment">#查看具体数值</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 拿到输出结果</span></span><br><span class="line">prob = mod.get_outputs()[<span class="number">0</span>].asnumpy()</span><br><span class="line">y = np.argsort(np.squeeze(prob))[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'truth label %d; top-1 predict label %d'</span> % (val_label[<span class="number">0</span>], y[<span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure>



<h4 id="mxnet如何获取中间层特征"><a href="#mxnet如何获取中间层特征" class="headerlink" title="mxnet如何获取中间层特征"></a>mxnet如何获取中间层特征</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这个主要是使用mx.symbol.Group([xxx,xxx])来多输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 方法一：定义模型的时候就把中间结果</span></span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line">net = mx.symbol.Variable(<span class="string">'data'</span>)</span><br><span class="line">fc1 = mx.symbol.FullyConnected(data=net, name=<span class="string">'fc1'</span>, num_hidden=<span class="number">128</span>)</span><br><span class="line">net = mx.symbol.Activation(data=fc1, name=<span class="string">'relu1'</span>, act_type=<span class="string">"relu"</span>)</span><br><span class="line">net = mx.symbol.FullyConnected(data=net, name=<span class="string">'fc2'</span>, num_hidden=<span class="number">64</span>)</span><br><span class="line">out = mx.symbol.SoftmaxOutput(data=net, name=<span class="string">'softmax'</span>)</span><br><span class="line"><span class="comment"># 通过把两个输出组成一个group来得到自己需要查看的中间层输出结果</span></span><br><span class="line">group = mx.symbol.Group([fc1, out]) </span><br><span class="line"><span class="built_in">print</span> group.list_outputs()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 方法二，在现有模型中将中间层拿出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line">sym, arg_params, aux_params = mx.model.load_checkpoint(<span class="string">'resnet-50'</span>,<span class="number">0</span>)<span class="comment">#载入模型</span></span><br><span class="line"></span><br><span class="line">args = sym.get_internals().list_outputs() <span class="comment">#获得所有中间输出</span></span><br><span class="line">internals = model.symbol.get_internals()</span><br><span class="line">fc1 = internals[<span class="string">'fc1_output'</span>]</span><br><span class="line">conv = internals[<span class="string">'stage4_unit3_conv1_output'</span>]</span><br><span class="line">group = mx.symbol.Group([fc1, sym, conv])  <span class="comment">#把需要输出的结果按group方式组合起来，这样就可以得到中间层的输出</span></span><br><span class="line"></span><br><span class="line">mod = mx.mod.Module(symbol=group,context=mx.gpu()) <span class="comment">#创建Module</span></span><br><span class="line">mod.bind(for_training=<span class="literal">False</span>,data_shapes=[(<span class="string">'data'</span>,(<span class="number">1</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>))]) <span class="comment">#绑定，此代码为预测代码，所以training参数设为False</span></span><br><span class="line">mod.set_params(arg_params,aux_params)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">filename</span>):</span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       <span class="built_in">print</span> <span class="string">'xxx'</span></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) <span class="comment">## BGR - &gt; RGB</span></span><br><span class="line">    img= np.transpose(img,(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)) <span class="comment">## channel first</span></span><br><span class="line">    img = img[np.newaxis,:] <span class="comment">## add batch -&gt; 4 dims</span></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Batch = namedtuple(<span class="string">'Batch'</span>,[<span class="string">'data'</span>])</span><br><span class="line">img = get_image(<span class="string">'val_1000/0.jpg'</span>) <span class="comment">#获取图片</span></span><br><span class="line">mod.forward(Batch([mx.nd.array(img)])) <span class="comment">#预测结果</span></span><br><span class="line">prob = mod.get_outputs()[<span class="number">0</span>].asnumpy()</span><br><span class="line">y = np.argsort(np.squeeze(prob))[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'truth label %d; top-1 predict label %d'</span> % (val_label[<span class="number">0</span>], y[<span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure>


<h3 id="Gluon篇"><a href="#Gluon篇" class="headerlink" title="Gluon篇"></a>Gluon篇</h3><h4 id="gluon调用MXNet模型（params-json）进行训练"><a href="#gluon调用MXNet模型（params-json）进行训练" class="headerlink" title="gluon调用MXNet模型（params+json）进行训练"></a>gluon调用MXNet模型（params+json）进行训练</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20622615/article/details/89924387">https://blog.csdn.net/qq_20622615/article/details/89924387</a></p>
<p>使用symbol得到的模型或者gluon的hybridize之后的模型包括一个.json文件（网络结构）和.params文件（参数），gluon可以使用net = gluon.SymbolBlock.imports(json, [‘data’], params, ctx)导入网络和参数，这样可以进行测试或者进一步训练。</p>
<p>但是如果只需要使用模型的其中一部分，比如只需要conv层，去掉所有fc层，或者再另外增加一些层， 这样直接导入就会比较复杂。正确的做法如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sym, arg_params, aux_params = mx.model.load_checkpoint(<span class="string">"1.0.3"</span>, <span class="number">40</span>)<span class="comment">#这里是model的名字和参数对应的epoch </span></span><br><span class="line">layers = sym.get_internals()<span class="comment">#得到所有的layers </span></span><br><span class="line">outputs = layers[<span class="string">'stage4_unit1_conv2_output'</span>]<span class="comment">#选择输出层 </span></span><br><span class="line">inputs = layers[<span class="string">'data'</span>]<span class="comment">#选择输入层 </span></span><br><span class="line">net = gluon.SymbolBlock(outputs, inputs)<span class="comment">#使用gluon的接口将其封装成一个新的net </span></span><br><span class="line">net.load_parameters(<span class="string">"1.0.3-0040.params"</span>, ignore_extra = <span class="literal">True</span>, allow_missing = <span class="literal">True</span>)<span class="comment">#载入数据 </span></span><br><span class="line">y = net(data) </span><br><span class="line"><span class="built_in">print</span>(y.shape) </span><br></pre></td></tr></tbody></table></figure>



<p>如果需要在该网络的基础上再新增加一些层，如下定义：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PretrainedNetwork</span>(gluon.HybridBlock):    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pretrained_layer, **kwargs</span>):        </span><br><span class="line">        <span class="built_in">super</span>(PretrainedNetwork, self).__init__(**kwargs)       </span><br><span class="line">        <span class="keyword">with</span> self.name_scope():            </span><br><span class="line">            self.pretrained_layer = pretrained_layer <span class="comment">#(n, 4, 4, 128)            </span></span><br><span class="line">            self.fc = nn.HybridSequential()            </span><br><span class="line">            self.fc.add(                        </span><br><span class="line">                nn.Flatten(),                        </span><br><span class="line">                nn.Dense(<span class="number">256</span>, activation = <span class="string">'relu'</span>), </span><br><span class="line">                nn.Dropout(rate = <span class="number">0.5</span>),</span><br><span class="line">                nn.Dense(<span class="number">128</span>)</span><br><span class="line">            )            </span><br><span class="line">            self.single_fc = nn.Dense(<span class="number">2</span>)            </span><br><span class="line">            self.fusion_fc = nn.Dense(<span class="number">2</span>)                </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hybrid_forward</span>(<span class="params">self, F, x</span>):        </span><br><span class="line">        x = self.pretrained_layer(x)        </span><br><span class="line">        x = self.fc(x)        </span><br><span class="line">        feat = x        </span><br><span class="line">        y1 = self.single_fc(x)        </span><br><span class="line">        feat = feat.<span class="built_in">sum</span>(axis = <span class="number">1</span>)        </span><br><span class="line">        y2 = self.fusion_fc(feat)        </span><br><span class="line">        <span class="keyword">return</span> y1, y2 </span><br></pre></td></tr></tbody></table></figure>



<p>通过下面的方式，使用预训练模型初始化其中一部分：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = PretrainedNetwork(pretrained_layer = net) </span><br><span class="line">net.initialize(forece_reinit = <span class="literal">False</span>, init = init.Xavier()) </span><br></pre></td></tr></tbody></table></figure>



<p><strong>需要注意的是，要先load_parameters再用其初始化PretrainedNwtwork</strong>，否则会出现prefix不匹配的问题。</p>
<p>如果需要fix其中一部分参数，只训练其中一部分，可以通过观察所有layer的名字，找到需要训练的layer。</p>
<p>print(net.collect_params())#打印所有的参数，这样可以看到所有的layer及其参数</p>
<p>在Trainer的params通过正则表达式选择需要训练的参数：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = gluon.Trainer(params = net.collect_params(<span class="string">"pretrained*|dense0*"</span>), optimizer = optimizer)</span><br></pre></td></tr></tbody></table></figure>

<p>这样没有被选中的参数就会被fix，训练中不会改变。</p>
<h4 id="导出Gluoncv的预训练模型"><a href="#导出Gluoncv的预训练模型" class="headerlink" title="导出Gluoncv的预训练模型"></a>导出Gluoncv的预训练模型</h4><p><strong>利用gluoncv的export_block导出gluoncv提供的预训练模型</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gluoncv</span><br><span class="line"><span class="keyword">from</span> gluoncv.utils <span class="keyword">import</span> export_block</span><br><span class="line"></span><br><span class="line">net = gluoncv.model-zoo.get_model(<span class="string">'ResNet101_v2'</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line">export_block(<span class="string">'resnet101'</span>, net, preprocess=<span class="literal">None</span>, layout=<span class="string">'CHW'</span>)</span><br></pre></td></tr></tbody></table></figure>


<h4 id="gluon训练"><a href="#gluon训练" class="headerlink" title="gluon训练"></a>gluon训练</h4><p>gluon主要有3个方法得到预训练模型：</p>
<ul>
<li>gluon自身的model_zoo</li>
<li>gluoncv提供的model_zoo</li>
<li>mxnet提供的预训练模型（*.params ，*.json）</li>
</ul>
<p>下面分别就这三个方面进行介绍</p>
<p><strong>1.读取gluon model_zoo提供的模型，并进行finetune</strong></p>
<p>gluon提供的model主要在gluon.model_zoo.vision下，模型地址：<a target="_blank" rel="noopener" href="https://mxnet.incubator.apache.org/api/python/gluon/model_zoo.html">https://mxnet.incubator.apache.org/api/python/gluon/model_zoo.html</a>,你可以根据自己的情况查找对应的模型进行使用。model_zoo提供的模型均为features+output结构</p>
<p><strong>调用方法如下：</strong></p>
<p><strong>一：只修改最终的fc层，进行finetune:</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon</span><br><span class="line">class_num = <span class="number">3</span></span><br><span class="line">ctx = [mx.gpu(<span class="number">0</span>),mx.gpu(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">finetune_net = gluon.model_zoo.vision.resnet50_v2(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> finetune_net.name_scope():</span><br><span class="line">    finetune_net.output = nn.Dense(class_num)</span><br><span class="line">finetune_net.output.initialize(init=mx.init.Xavier(),ctx=ctx)</span><br><span class="line">finetune_net.hybridize()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p><strong>二：不仅仅修改最终的fc层，还可以增加几层</strong></p>
<p>下面的方法，首先提取出features，然后构建增加的sequential,最后将两部分通过sequential合并在一起。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon</span><br><span class="line">pretrained_net = gluon.model_zoo.vision.resnet50_v2(pretrained=<span class="literal">True</span>)</span><br><span class="line">pretrained_net_features = pretrained_net.features</span><br><span class="line"></span><br><span class="line">class_num = <span class="number">3</span></span><br><span class="line">ctx = [mx.gpu(<span class="number">0</span>),mx.gpu(<span class="number">1</span>)]</span><br><span class="line">modify_net = nn.HybridSequential(prefix=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">with</span> modify_net.name_scope():</span><br><span class="line">    modify_net.add(nn.Dense(<span class="number">128</span>,activation=<span class="string">'relu'</span>),</span><br><span class="line">                nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">                nn.Dense(class_num))</span><br><span class="line">    modify_net.collect_params().initialize(init=mx.init.Xavier(),ctx=ctx)</span><br><span class="line">    </span><br><span class="line">net = nn.HybridSequential(prefix=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">with</span> modify_net.name_scope():</span><br><span class="line">    net.add(pretrained_net_features)</span><br><span class="line">    net.add(modify_net)</span><br><span class="line">net.hybridize() <span class="comment">## 该语句代表静态图动态图切换。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>也可以直接修改features,达到同样的效果,不过记得初始化</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon</span><br><span class="line">class_num = <span class="number">3</span></span><br><span class="line">ctx = [mx.gpu(<span class="number">0</span>),mx.gpu(<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">finetune_net = gluon.model_zoo.vision.resnet50_v2(pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> finetune_net.name_scope():</span><br><span class="line">    finetune_net.features.add(nn.Dense(<span class="number">128</span>,activation=<span class="string">'relu'</span>),</span><br><span class="line">                              nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">    finetune_net.output = nn.Dense(class_num)</span><br><span class="line">finetune_net.features.initialize(init=mx.init.Xavier(),force_init=<span class="literal">False</span>,ctx=ctx)</span><br><span class="line">finetune_net.output.initialize(init=mx.init.Xavier(),ctx=ctx)</span><br><span class="line">finetune_net.hybridize()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>2.读取gluoncv model_zoo提供的模型，并进行finetune(==推荐==)</strong></p>
<p>gluoncv是gluon提供的比较强大的视觉库，其中提供了很多的预训练模型可以使用，链接：<a target="_blank" rel="noopener" href="https://gluon-cv.mxnet.io/model_zoo/classification.html">https://gluon-cv.mxnet.io/model_zoo/classification.html</a></p>
<p><strong>使用gluoncv的预训练模型也很方便，跟使用gluon的model_zoo方法基本一致，不同点如下：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gluoncv.model_zoo <span class="keyword">import</span> get_model</span><br><span class="line"></span><br><span class="line">finetune_net = get_model(<span class="string">'ResNet50_v2'</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>其他的就跟上面的一致了。</p>
<p><strong>3.直接读取mxnet模型（ .params + .json）</strong></p>
<p>有的时候，我们可能需要利用gluon读取mxnet模型，目前利用gluon读取mxnet模型，只能使用gluon.nn.SymbolBlock()进行读取，如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx = mx.gpu(0)</span><br><span class="line">sym, arg_params, aux_params = mx.model.load_checkpoint('../model/resnetv1d-101',17) ## model path and model index</span><br><span class="line">internals = sym.get_internals()</span><br><span class="line">net_out = internals['fc1_output']</span><br><span class="line"></span><br><span class="line">net = gluon.nn.SymbolBlock(outputs=net_out, inputs=mx.sym.var('data'))</span><br><span class="line"></span><br><span class="line">net.load_params(filename='../model/resnetv1d-101-0017.params', ctx=ctx)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如上，我们便读取了mxnet的model,现在我们便可以对net进行操作了，如下代码构建了一个3分类的网络：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class_num = <span class="number">3</span></span><br><span class="line">finetune_net = nn.HybridSequential(prefix=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">with</span> finetune_net.name_scope():</span><br><span class="line">    finetune_net.add(net)</span><br><span class="line">    finetune_net.add(nn.Dense(class_num))<span class="comment">## 输出3分类</span></span><br><span class="line">net.hybridize() <span class="comment">## 该语句代表静态图动态图切换。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>4.最优雅的方式，重新定义网络，实现任意的操作</strong></p>
<p>这种方法最为优雅，也最灵活，你可以采用上面个各个方法读取模型，然后重写forward，实现网络的任意操作</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PretrainedNetwork</span>(gluon.HybridBlock):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pretrained_layer, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(PretrainedNetwork, self).__init__(**kwargs)</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.pretrained_layer = pretrained_layer </span><br><span class="line">            self.fc = nn.HybridSequential()</span><br><span class="line">            self.fc.add(</span><br><span class="line">                        nn.Flatten(),</span><br><span class="line">                        nn.Dense(<span class="number">256</span>, activation = <span class="string">'relu'</span>),</span><br><span class="line">                        nn.Dropout(rate = <span class="number">0.5</span>),</span><br><span class="line">                        nn.Dense(<span class="number">128</span>)</span><br><span class="line">                        )</span><br><span class="line">            self.output = nn.Dense(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hybrid_forward</span>(<span class="params">self, F, x</span>):  <span class="comment">## 这里注意F不要忘记。</span></span><br><span class="line">        x = self.pretrained_layer(x)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        out = self.output(x)</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">### 采用如下得到网络：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gluoncv.model_zoo <span class="keyword">import</span> get_model</span><br><span class="line"></span><br><span class="line">finetune_net = get_model(<span class="string">'ResNet50_v2'</span>, pretrained=<span class="literal">True</span>)    </span><br><span class="line">net = PretrainedNetwork(pretrained_layer = finetune_net)</span><br><span class="line">net.initialize(forece_reinit = <span class="literal">False</span>, init = init.Xavier()) <span class="comment">## 初始化</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="四、其他的杂七杂八"><a href="#四、其他的杂七杂八" class="headerlink" title="四、其他的杂七杂八"></a>四、其他的杂七杂八</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">body = mx.sym.Convolution(data=data, num_filter=<span class="number">64</span>, kernel=(<span class="number">7</span>, <span class="number">7</span>), stride=(<span class="number">2</span>,<span class="number">2</span>), pad=(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                  no_bias=<span class="literal">True</span>, name=<span class="string">"conv1"</span>, workspace=workspace)                      </span><br><span class="line"><span class="comment"># 最大值池化     </span></span><br><span class="line">body = mx.sym.Pooling(data=body, kernel=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">2</span>,<span class="number">2</span>), pad=(<span class="number">1</span>,<span class="number">1</span>), pool_type=<span class="string">'max'</span>)</span><br><span class="line"><span class="comment"># 均值池化</span></span><br><span class="line">body = mx.symbol.Pooling(data=body, kernel=(<span class="number">7</span>,<span class="number">7</span>) , pool_type=<span class="string">'avg'</span> , name = <span class="string">'avg1'</span>)</span><br><span class="line"><span class="comment"># global average pooling </span></span><br><span class="line">pool = mx.sym.Pooling(data=last_fm, kernel=(pool_size, pool_size), stride=(<span class="number">1</span>, <span class="number">1</span>), </span><br><span class="line">                              pool_type=<span class="string">"avg"</span>, name=<span class="string">"global_pool"</span>, global_pool=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># BN</span></span><br><span class="line">body = mx.sym.BatchNorm(data=body, fix_gamma=<span class="literal">False</span>, momentum=<span class="number">0.9</span>, eps=<span class="number">2e-5</span>, name=<span class="string">'bn1'</span>)</span><br><span class="line">*注*eps参数是在cudnn中使用的，目的是防止除数为<span class="number">0</span>的情况，默认参数是<span class="number">0.001</span>，这里使用的是<span class="number">0.00002</span></span><br><span class="line"><span class="comment"># RELU  </span></span><br><span class="line">body = mx.sym.Activation(data=body, act_type=<span class="string">'relu'</span>, name=<span class="string">'relu0'</span>)</span><br></pre></td></tr></tbody></table></figure>



</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/25/mxnet/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/25/mobilenet-v3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/mobilenet-v3/" class="post-title-link" itemprop="url">MobileNet-V3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 08:50:21" itemprop="dateCreated datePublished" datetime="2019-12-25T08:50:21+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 13:48:02" itemprop="dateModified" datetime="2020-01-16T13:48:02+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Classification/" itemprop="url" rel="index">
                    <span itemprop="name">Classification</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/25/mobilenet-v3/" class="post-meta-item leancloud_visitors" data-flag-title="MobileNet-V3" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/25/mobilenet-v3/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/mobilenet-v3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>mobilenet-v3是Google继mobilenet-v2之后的又一力作，作为mobilenet系列的新成员，自然效果会提升，mobilenet-v3提供了两个版本，分别为mobilenet-v3 large 以及mobilenet-v3 small，分别适用于对资源不同要求的情况，论文中提到，<strong>mobilenet-v3 small在imagenet分类任务上，较mobilenet-v2，精度提高了大约3.2%，时间却减少了15%，mobilenet-v3 large在imagenet分类任务上，较mobilenet-v2，精度提高了大约4.6%，时间减少了5%，mobilenet-v3 large 与v2相比，在COCO上达到相同的精度，速度快了25%<strong>，同时在分割算法上也有一定的提高。本文还有一个亮点在于，</strong>网络的设计利用了NAS（network architecture search）算法以及NetAdapt algorithm算法</strong>。并且，本文还介绍了一些提升网络效果的trick，这些trick也提升了不少的精度以及速度。</p>
</blockquote>
<hr>
<p><strong>论文名称:Searching for MobileNetV3</strong></p>
<p><strong>作者：Googler</strong></p>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1905.02244"><strong>论文链接</strong>：https://arxiv.org/abs/1905.02244</a></p>
<hr>
<h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>近年来，随着智能应用的不断增加，轻量化网络成为近年来的一个研究热点，毕竟不是所有设备都有GPU来计算的，轻量化 网络顾名思义，就是网络的参数量比较少，速度较快，下面总结了目前常用的一些减少网络计算量的方法：</p>
<ul>
<li>基于轻量化网络设计：比如mobilenet系列，shufflenet系列， Xception等，使用Group卷积、1x1卷积等技术减少网络计算量的同时，尽可能的保证网络的精度。</li>
<li>模型剪枝： 大网络往往存在一定的冗余，通过剪去冗余部分，减少网络计算量。</li>
<li>量化：利用TensorRT量化，一般在GPU上可以提速几倍。</li>
<li>知识蒸馏：利用大模型（teacher model）来帮助小模型（student model）学习，提高student model的精度。</li>
</ul>
<p>mobilenet系列当然是典型的第一种方法。在介绍mobilenet v3前，先来回顾一下mobilenet v1和v2的创新点：</p>
<p><strong>mobilenet v1</strong></p>
<ul>
<li>利用分组卷积降低网络的计算量，并且mobilenet将分组卷积应用到极致，即网络的分组数与网络的channel数量相等，使网络的计算量减到最低，但是这样channel之间的交互就没有了，所以作者又使用的point-wise conv,即使用1x1的卷积进行channel之间的融合。</li>
<li>直筒结构。</li>
</ul>
<p><strong>mobilenet v2:</strong></p>
<ul>
<li>引入了bottleneck结构。</li>
<li>将bottleneck结构变成了纺锤型，即resnet是先缩小为原来的1/4，再放大，他是放大到原来的6倍，再缩小。</li>
<li>并且去掉了Residual Block最后的ReLU。</li>
</ul>
<p><strong>那么mobilenet v3又引入了哪些黑科技呢？：</strong></p>
<p><strong>话不多说，直接上重点</strong></p>
<ul>
<li>1.引入SE结构<br>在bottlenet结构中加入了SE结构，并且放在了depthwise filter之后，如下图。<strong>因为SE结构会消耗一定的时间，所以作者在含有SE的结构中，将expansion layer的channel变为原来的1/4,这样作者发现，即提高了精度，同时还没有增加时间消耗。并且SE结构放在了depthwise之后。</strong></li>
</ul>
<p><img src="/1.png" alt="在这里插入图片描述"></p>
<ul>
<li>2.修改尾部结构：<br>在mobilenetv2中，在avg pooling之前，存在一个1x1的卷积层，目的是提高特征图的维度，更有利于结构的预测，但是这其实带来了一定的计算量了，所以这里作者修改了，将其放在avg pooling的后面，首先利用avg pooling将特征图大小由7x7降到了1x1，降到1x1后，然后再利用1x1提高维度，这样就减少了7x7=49倍的计算量。并且为了进一步的降低计算量，作者直接去掉了前面纺锤型卷积的3x3以及1x1卷积，进一步减少了计算量，就变成了如下图第二行所示的结构，作者将其中的3x3以及1x1去掉后，精度并没有得到损失。这里降低了大约15ms的速度。</li>
</ul>
<p><img src="/2.png" alt="在这里插入图片描述"></p>
<ul>
<li>3.修改channel数量<br>修改头部卷积核channel数量，mobilenet v2中使用的是32 x 3 x 3，作者发现，其实32可以再降低一点，所以这里作者改成了16，在保证了精度的前提下，降低了3ms的速度。，这里给出了mobilenet v2以及mobilenet v3的结构对比：</li>
</ul>
<p><img src="/3.png" alt="3.png"><br><img src="/4.png" alt="在这里插入图片描述"></p>
<ul>
<li>4.非线性变换的改变<br>使用h-swish替换swish，swish是谷歌自家的研究成果，颇有点自卖自夸的意思，这次在其基础上，为速度进行了优化。swish与h-swish公式如下所示，由于sigmoid的计算耗时较长，特别是在移动端，这些耗时就会比较明显，所以作者使用ReLU6(x+3)/6来近似替代sigmoid，观察下图可以发现，其实相差不大的。<strong>利用ReLU有几点好处，1.可以在任何软硬件平台进行计算，2.量化的时候，它消除了潜在的精度损失，使用h-swish替换swith，在量化模式下回提高大约15%的效率，另外，h-swish在深层网络中更加明显。</strong></li>
</ul>
<p>$$swish(x)=x*\sigma(x)$$</p>
<p>$$h-swish[x]=x*frac{ReLU6(x+3)}{6}$$<br><img src="https://img-blog.csdnimg.cn/20190613144714722.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190613144629645.png" alt="在这里插入图片描述"><br><img src="/5.png" alt="在这里插入图片描述"><br>如下两张图展示的是使用h-swish对于时间以及精度的影响，可以发现，使用h-swish@16可以提高大约0.2%的精度，但是持剑延长了大约20%。<br><img src="/6.png" alt="在这里插入图片描述"></p>
<p><strong>虽然mobilenet v3结构你已经知道了，但是，本文的重点，如何设计出的这个网络，即如何进行网络结构的搜索，还是有必要提一下的，这里我也没有细细研究，想深入了解的同学可以自行对应阅读论文</strong></p>
<p><strong>总体过程很简单，先通用NAS算法，优化每一个block，得到大体的网络结构，然后使用NetAdapt 算法来确定每个filter的channel的数量</strong></p>
<p><strong>这里由于small model的精度以及耗时影响相对较大，mobilenet v3 large和mobilenet v3 small是分别使用NAS设计的。</strong></p>
<p><strong>NAS之后，可以使用NetAdapt算法设计每个layer，过程如下：</strong></p>
<ul>
<li><p>先用NAS找到一个可用的结构A。</p>
</li>
<li><ol>
<li>在A的基础上生成一系类的候选结构，并且这些候选结构消耗在一点点减少，其实就是穷举子结构。</li>
<li>对于每个候选结构，使用前一个模型进行初始化，（前一个模型没有的参数随机初始化就行），finetune T个epoch，得到一个大致的精度。</li>
<li>在这些候选结构中，找到最好的。</li>
</ol>
</li>
<li><p>反复迭代，知道目标时间到达，找到最合适的结果。</p>
</li>
</ul>
<p><strong>候选是怎么选取的呢?</strong></p>
<ul>
<li>降低expansion layer的size.</li>
<li>减少botleneck</li>
</ul>
<h4 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h4><p>首先是分类部分的实验，向来比较豪的谷歌这次也不例外，作者使用16块TPU，batchsize为4096进行训练。然后作者选择在Google的Pixel Phone进行测试。</p>
<p>下图为作者ImageNet网络的测试结果，结果可以看出V3 large相比较与V2 1.0 精度上提高了大约3个点，但是速度却从78ms下降到66ms(Pixel-1手机)，V3 small 相比较与V2 0.35,精度从60%提高到了67%，速度稍有增加，从19ms增加到21ms(Pixel-1手机).<br><img src="/7.png" alt="在这里插入图片描述"></p>
<p>下图对比了不同的google phone上面，模型量化后（<strong>float量化，非int8量化</strong>）的耗时，其中P-1,P-2,P-3分别代表的是不同性能的手机。我这里主要分析一下V3-Large网络吧，可见量化后，TOP-1精度从上面图的75.2%下降到了73.8%，降低了大约1.5个点，符合正常情况，在P1-P3的加速效果来看P1加速了9ms(66ms)，P2加速了20ms(77ms)，P3加速了15ms(52.6ms)。与V2网络相比，其实速度相差不大，（<strong>为啥原本速度相差还挺大，量化之后相差不大了呢？这是个值得考虑的问题</strong>）<br><img src="/8.png" alt="在这里插入图片描述"></p>
<p>下图是作者实验了使用不同的分辨率以及不同的模型深度的精度对比，分辨率分别选择的是[96,128,160,192,224,256],深度分别选为原来的[0.35,0.5,0.75,1.0,1.25]。可见，其实resolution对于精度以及速度的平衡效果更好，可以达到更快的速度，同时精度没有改变模型深度精度低，反而更高。（但是很多时候，其实分辨率的大小是根据场景决定的，比如检测和分割就需要较大尺度的图像）。<br><img src="/9.png" alt="在这里插入图片描述"></p>
<p>下图展示了从MnasNet经过一系列的修改，到mobileNet v3的精度与速度变化的过程。<br><img src="/10.png" alt="在这里插入图片描述"><br>下图是将mobilenet v3应用于SSD-Lite在COCO测试集的精度结果。观察可以发现，在V3-Large上面，mAP没有特别大的提升但是速度确实降低了一些的。<br><img src="/11.png" alt="在这里插入图片描述"><br>下图是分割的结构图，这里就不详细介绍了，感兴趣的读者可以自行看论文。<br><img src="/12.png" alt="在这里插入图片描述"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结来看，mobilenet V3其实并没有惊艳的结构提出，最主要的还是应用了诸如SE、H-Swish等tricks，然后利用Google前面提出的NAS以及NetAdapt算法进行结构的自动搜索，提升了一定的精度，降低了一定的速度。可能本篇论文的重点更在于进一步展示一下网络自动结构搜索的有效性，这样对应了文中的标题：Searching for，毕竟这也是发展的一个势头。</p>
<p><strong>文中有不足或错误的地方，欢迎广大小伙伴批评指正。</strong></p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/25/mobilenet-v3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/25/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/git/" class="post-title-link" itemprop="url">Git操作总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 08:46:57" itemprop="dateCreated datePublished" datetime="2019-12-25T08:46:57+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 13:46:46" itemprop="dateModified" datetime="2020-01-16T13:46:46+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/25/git/" class="post-meta-item leancloud_visitors" data-flag-title="Git操作总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/25/git/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/git/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>git基本操作总结</p>
</blockquote>
<h3 id="git更新操作（最经常使用-）"><a href="#git更新操作（最经常使用-）" class="headerlink" title="git更新操作（最经常使用 ）"></a>git更新操作（最经常使用 ）</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status           <span class="comment">#查看git当前状态</span></span><br><span class="line">git diff server.py   <span class="comment">#查看server.py 在git当中</span></span><br><span class="line">git add .            <span class="comment">#将当前修改提交到 git</span></span><br><span class="line">git commit -m “change threshold <span class="keyword">for</span> higher precision”</span><br><span class="line">git branch</span><br><span class="line">git push origin master</span><br><span class="line">git push --set-upstream origin vulgar <span class="comment">#设置上传的分支</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="git新建任务并上传已有文件夹项目"><a href="#git新建任务并上传已有文件夹项目" class="headerlink" title="git新建任务并上传已有文件夹项目"></a>git新建任务并上传已有文件夹项目</h3><p>首先在git网页上手动创建对应名字的项目</p>
<p>然后按照下面代码进行上传</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin ssh://git@g.hz.netease.com:22222/wanglichun/liquid.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">git push -u origin master</span><br><span class="line">Push an existing Git repository</span><br></pre></td></tr></tbody></table></figure>

<h3 id="git新建分支并上传文件的方法"><a href="#git新建分支并上传文件的方法" class="headerlink" title="git新建分支并上传文件的方法"></a>git新建分支并上传文件的方法</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、Git init （在本地工程目录下），生成.git 文件夹</span></span><br><span class="line">Git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、上传修改的文件</span></span><br><span class="line">git add *  <span class="comment">#(*可替换成具体要上传的文件名，*表示提交所有有变化的文件)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、添加上传文件的描述</span></span><br><span class="line">git commit -m <span class="string">"test"</span> <span class="comment">#（”test“为描述）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、创建分支</span></span><br><span class="line">git branch <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5（切换分支</span></span><br><span class="line">git checkout <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、与远程分支相关联</span></span><br><span class="line">git remote add origin https://github.com/yangxiaoyan20/BowlingScore.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7、上传到对应分支</span></span><br><span class="line">git push origin <span class="built_in">test</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="git其他命令"><a href="#git其他命令" class="headerlink" title="git其他命令"></a>git其他命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git add&lt;file&gt; ,可以向git添加文件，当然可以添加多个文件如：git add a.txt  b.txt</span><br><span class="line"></span><br><span class="line">git commit -m &lt;message&gt; 提交代码 message为修改备注，方便回溯</span><br><span class="line"></span><br><span class="line">git log 可以查看提交日志</span><br><span class="line"></span><br><span class="line">git status 可以查看那个当前状态</span><br><span class="line"></span><br><span class="line">git diff xxx  查看不同</span><br><span class="line"></span><br><span class="line">git checkout -- readme.txt 可以让文件回退到最近一次git commit或者git add的状态</span><br><span class="line"></span><br><span class="line">git rm 删除文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加github流程： 首先本地git建好，github同样建好repository，</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:lichun-wang/[name].git</span><br><span class="line"></span><br><span class="line">git push  -u origin master</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>






<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1 .dockerignore容易被.gitignore给忽略掉，所以需要使用如下代码上传才行。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -f .dockerignore</span><br></pre></td></tr></tbody></table></figure>

<p>2 配置github ssh-key</p>
<p>ssh-keygen，一路回车就好了，生成ssh key<br>在github网站中-&gt;setting-&gt;SSH-&gt;add new ssh,title就可以填 id_rsa.pub<br>ssh -T <a href="mailto:git@github.com">git@github.com</a> 验证是否成功</p>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/25/git/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wanglichun.tech/2019/12/22/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="Spring Wang">
      <meta itemprop="description" content="众里寻他千百度，蓦然回首，那人却在灯火阑珊处">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spring's Idea">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/docker/" class="post-title-link" itemprop="url">Docker的使用与总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 08:01:52" itemprop="dateCreated datePublished" datetime="2019-12-22T08:01:52+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-16 13:53:52" itemprop="dateModified" datetime="2020-01-16T13:53:52+08:00">2020-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/22/docker/" class="post-meta-item leancloud_visitors" data-flag-title="Docker的使用与总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/22/docker/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/22/docker/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body></body></html><html><head></head><body><blockquote>
<p>在程序开发过程中，经常需要我们去配置各种开发环境，而本地与线上还可能存在环境依赖的不同，导致出现一些不知名的bug，这个时候不要抓头，是时候使用docker来帮你排忧解难了,下面我通过下面几个篇章来介绍Docker.</p>
</blockquote>
<h3 id="原理介绍篇"><a href="#原理介绍篇" class="headerlink" title="原理介绍篇"></a>原理介绍篇</h3><h4 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h4><p>docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行的Linux容器解决方案。</p>
<p>简单来说就是，docker可以将你的环境进行封装，并且程序在docker内运行，有了docker，你就再也不用担心环境问题了。</p>
<h4 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h4><p><strong>更高效的利用系统资源</strong></p>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统 资源的利用率更高。</p>
<p>无论是应用执行速度、内存损耗或者文件存储速度，都要比传 统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运 行更多数量的应用。</p>
<p><strong>更快速的启动时间</strong></p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接 运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。</p>
<p><strong>一致的运行环境</strong></p>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环 境不一致，导致有些 bug 并未在开发过程中被发现。</p>
<p>而 Docker 的镜像提供了除内 核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。</p>
<p><strong>持续交付和部署</strong></p>
<p>对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意 地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员 可以通过 Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration) 系 统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>
<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环 境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<p><strong>更轻松的迁移</strong></p>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在 很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运 行结果是一致的。</p>
<p>因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一 个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h3 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h3><p>一般，如果使用GPU，一般要安装<strong>Docker, Nvidia-Docker,Docker-Compose,Nvidia-Docker-Compse</strong></p>
<h4 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h4><p>参考官方安装链接： <a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>
<p>按官方教程docker ce（community edtion），并按教程测试docker是否成功安装。比如我们以Ubuntu Xenial 16.04 (LTS)为例：<br>下载Docker安装包，在这里<a target="_blank" rel="noopener" href="https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/%E6%8C%91%E9%80%89%E6%9C%80%E6%96%B0%E7%9A%84Docker%E7%89%88%E6%9C%AC%E3%80%82">https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/挑选最新的Docker版本。</a><br>安装：sudo dpkg -i /path/to/package.deb<br>测试：sudo docker run hello-world<br>(可选）Linux环境下的权限变更，这样不用每次docker命令都加sudo，自己没服务器权限找管理员变更。</p>
<h4 id="Nvidia-Docker-的安装"><a href="#Nvidia-Docker-的安装" class="headerlink" title="Nvidia-Docker 的安装"></a>Nvidia-Docker 的安装</h4><p>参考官方安装链接： <a target="_blank" rel="noopener" href="https://github.com/NVIDIA/nvidia-docker">https://github.com/NVIDIA/nvidia-docker</a></p>
<p>nvidia-docker已经升级到nvidia-docker2，本测试是在nvidia-docker 1.0基础上完成的，1.0的安装方法请看上面教程链接。</p>
<p>Test nvidia-smi with the latest official CUDA image</p>
<p>docker run –runtime=nvidia –rm nvidia/cuda nvidia-smi</p>
<h4 id="docker-compose的安装"><a href="#docker-compose的安装" class="headerlink" title="docker-compose的安装"></a>docker-compose的安装</h4><p>参考官方安装链接：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></p>
<p>到<a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases%E4%B8%8B%E8%BD%BDlinux%E7%89%88%E6%9C%AC%E3%80%82">https://github.com/docker/compose/releases下载linux版本。</a><br>重命名为docker-compose并放到/usr/local/bin/下面<br>增加执行权限：sudo chmod +x /usr/local/bin/docker-compose<br>测试： docker-compose –version</p>
<h4 id="nvidia-docker-compose的安装"><a href="#nvidia-docker-compose的安装" class="headerlink" title="nvidia-docker-compose的安装"></a>nvidia-docker-compose的安装</h4><p>sudo pip install nvidia-docker-compose</p>
<p>注意：nvidia-docker-compose和nvidia-docker2不兼容，如果安装了nvidia-docker2，那就不需要安装这个compose了</p>
<h3 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h3><p>使用容器必然需要容器镜像，镜像是容器环境的存储形式。容器的运行要从镜像开始。</p>
<h4 id="如何构建镜像？"><a href="#如何构建镜像？" class="headerlink" title="如何构建镜像？"></a>如何构建镜像？</h4><p>1.简单方法，docker pull</p>
<p>dockerhub上面存在很多别人上传好的镜像，如果有合适的可以自己从上面直接拉，很方便。命令如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull pytorch/pytorch:1.3-cuda10.1-cudnn7-runtime</span><br></pre></td></tr></tbody></table></figure>


<p>2.在docker内直接安装</p>
<p>如果在dockerhub上面拉下来的镜像满足了你大部分的需求，但是缺少了几个环境怎么办呢？可以在已经拉下来的镜像中直接安装，安装完对应的库之后，commit就可以了。</p>
<p>例子如下：</p>
<p>在ubuntu容器中安装vim后保存。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu   # 运行docker</span><br><span class="line">yum install -y vim      # 安装vim</span><br><span class="line">exit                    # 退出</span><br><span class="line">docker container ls -a  # 查看容器,找到刚才安装后的容器</span><br><span class="line">docker commit 059fdea031ba chaoyu/centos-vim  # 提交容器，前面参数是id,后面参数是名字</span><br></pre></td></tr></tbody></table></figure>

<p><strong>但是这种方式不推荐，因为安装了哪些东西，容易忘记，不好复现</strong></p>
<p>3.通过Dockerfile安装</p>
<p>Dockerfile可以帮助你解决2中，时间长，容易忘记，不好复现的问题，通过Dockerfile，你可以从你的基础镜像开始，一步一步的安装，得到最终的结果。</p>
<p>就像下面这样：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<p><strong>下面是构建Dockerfile常用命令的一些解释</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04 #带有tag的base image</span><br><span class="line"></span><br><span class="line">LABEL version=“1.0” #容器元信息，帮助信息，Metadata，类似于代码注释</span><br><span class="line">LABEL maintainer=“yc_uuu@163.com"</span><br><span class="line"></span><br><span class="line">#对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！</span><br><span class="line">RUN yum update &amp;&amp; yum install -y vim \</span><br><span class="line">    Python-dev #反斜线换行</span><br><span class="line">RUN /bin/bash -c "source $HOME/.bashrc;echo $HOME”</span><br><span class="line"></span><br><span class="line">WORKDIR /app #相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd</span><br><span class="line">RUN pwd     # 打印结果应该是/test/demo</span><br><span class="line"></span><br><span class="line">ADD and COPY </span><br><span class="line">ADD hello /  # 把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录</span><br><span class="line">ADD test.tar.gz /  # 添加到根目录并解压</span><br><span class="line"></span><br><span class="line">WORKDIR /root</span><br><span class="line">ADD hello test/  # 进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径</span><br><span class="line">COPY hello test/  # 等同于上述ADD效果</span><br><span class="line"></span><br><span class="line">ADD与COPY</span><br><span class="line">   - 优先使用COPY命令</span><br><span class="line">    -ADD除了COPY功能还有解压功能</span><br><span class="line">添加远程文件/目录使用curl或wget</span><br><span class="line"></span><br><span class="line">ENV # 环境变量，尽可能使用ENV增加可维护性</span><br><span class="line">ENV MYSQL_VERSION 5.6 # 设置一个mysql常量</span><br><span class="line">RUN yum install -y mysql-server=“${MYSQL_VERSION}” </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>构建好Dockerfile之后，就可以使用下面的命令构建镜像了</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t [docker name] .</span><br><span class="line">docker build --network=host  -t [docker name]  .      ### 修改网络,使用本机网络，如果有些库安装的时候下载不下来可以试试这个参数。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="镜像的运行"><a href="#镜像的运行" class="headerlink" title="镜像的运行"></a>镜像的运行</h4><p>1.启动一个bash终端,允许用户进行交互</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v $HOME/history:/history/ dockername /bin/bash  </span><br><span class="line"></span><br><span class="line">或者指定运行网络为主机网络：</span><br><span class="line"></span><br><span class="line">docker run --net=host --rm -it -v $HOME/history:/history/  pytorch:nightly-gpu /bin/bash </span><br><span class="line"></span><br><span class="line"># --name  给容器定义一个名称</span><br><span class="line"># -i 让容器的标准输入保持打开。</span><br><span class="line"># -t 让Docker分配一个伪终端,并绑定到容器的标准输入上。</span><br><span class="line"># -v 将本机路径映射到容器中，实现在容器中的操作。</span><br><span class="line"># /bin/bash 指定docker容器，用shell解释器交互。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>2.利用docker-compose运行docker服务</p>
<p>上面1中的命令好长，如果映射多个路径岂不很麻烦，而且启动容器后，没有办法与本地文件进行交互，有没有更方便的使用容器的方法？当然有</p>
<p>使用docker-compose，docker-compose可以实现本地文件到docker内的映射，这样你在本地直接修改程序，docker内就同步修改了，比较方便。</p>
<p>使用docker-compose首先要创建docker-compose.yml文件，参考如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># yml配置文件格式版本为2, 镜像名字为webspring</span><br><span class="line">version: '2'</span><br><span class="line">services:</span><br><span class="line">  webspring:</span><br><span class="line">    build: .  # 如果没有下面image的镜像，默认在当前路径下的Dockerfile运行</span><br><span class="line">    image: tf-demo/docker:0.0.1  # 默认运行的镜像</span><br><span class="line"># 映射端口</span><br><span class="line">    shm_size: '2gb' ## 代表交换空间，可省略</span><br><span class="line">    ports:</span><br><span class="line">    - "8888:8888"</span><br><span class="line">    - "8887:6006"</span><br><span class="line"># 映射文件路径</span><br><span class="line">    volumes:</span><br><span class="line">    - .:/app</span><br></pre></td></tr></tbody></table></figure>


<p>创建好后，运行下面的命令启动服务就可以啦。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run --rm  webspring bash</span><br></pre></td></tr></tbody></table></figure>

<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>1.在运行的容器中，使用exits退出<br>2.直接将对应的docker stop掉</p>
<blockquote>
<p>这里一般先使用docker ps查看docker的运行情况，然后使用 docker stop xxxx 来将对应的容器停止掉。</p>
</blockquote>
<p><strong>记得经常去清一下缓存(很重要)：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -qf status=exited)</span><br></pre></td></tr></tbody></table></figure>


<h4 id="发布到仓库"><a href="#发布到仓库" class="headerlink" title="发布到仓库"></a>发布到仓库</h4><p>docker提供了一个类似于github的仓库docker hub，官方网站（需注册使用）<br><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 注册docker id后，在linux中登录dockerhub</span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"># 注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tag</span><br><span class="line">docker tag haha/vim springwang/vim</span><br><span class="line"># 语法是：  docker tag   仓库名   springwang/仓库名</span><br><span class="line"></span><br><span class="line"># 推送docker image到dockerhub</span><br><span class="line">docker push springwang/vim:latest</span><br><span class="line"></span><br><span class="line"># 去dockerhub中检查镜像</span><br><span class="line"># 先删除本地镜像，然后再测试下载pull 镜像文件</span><br><span class="line">docker pull springwang/vim:latest</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="保持到本地"><a href="#保持到本地" class="headerlink" title="保持到本地"></a>保持到本地</h4><ol>
<li>保存镜像</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save imageID &gt; filename</span><br><span class="line">docker load &lt; filename</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>保存容器</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker export containID &gt; filename</span><br><span class="line">docker <span class="keyword">import</span> filename [newname]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="多用户使用docker"><a href="#多用户使用docker" class="headerlink" title="多用户使用docker"></a>多用户使用docker</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 创建docker用户组</span><br><span class="line">sudo groupadd docker </span><br><span class="line"></span><br><span class="line">2. 应用用户加入docker用户组</span><br><span class="line">sudo usermod -aG docker ${USER} </span><br><span class="line">3. 重启docker服务</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">4.查看docker信息</span><br><span class="line">docker info</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Docker-常用命令总结"><a href="#Docker-常用命令总结" class="headerlink" title="Docker 常用命令总结"></a>Docker 常用命令总结</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker search  hello-docker  # 搜索hello-docker的镜像</span><br><span class="line">docker search centos # 搜索centos镜像</span><br><span class="line">docker pull hello-docker # 获取centos镜像</span><br><span class="line">docker run  hello-world   #运行一个docker镜像，产生一个容器实例（也可以通过镜像id前三位运行）</span><br><span class="line">docker image ls  # 查看本地所有镜像</span><br><span class="line">docker images  # 查看docker镜像</span><br><span class="line">docker image rmi -f hello-docker # 删除centos镜像</span><br><span class="line">docker ps  #列出正在运行的容器（如果创建容器中没有进程正在运行，容器就会立即停止）</span><br><span class="line">docker ps -a  # 列出所有运行过的容器记录</span><br><span class="line">docker save centos &gt; /opt/centos.tar.gz  # 导出docker镜像至本地</span><br><span class="line">docker load &lt; /opt/centos.tar.gz   #导入本地镜像到docker镜像库</span><br><span class="line">docker stop  `docker ps -aq`  # 停止所有正在运行的容器</span><br><span class="line">docker  rm `docker ps -aq`    # 一次性删除所有容器记录</span><br><span class="line">docker rmi  `docker images -aq`   # 一次性删除所有本地的镜像记录</span><br><span class="line">docker container ls -a # 检查运行中的容器</span><br><span class="line">docker tag id  new_name  # 重命名docker images</span><br><span class="line">docker system prune  # 清楚docker缓存</span><br></pre></td></tr></tbody></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>dockerignore容易被.gitignore给忽略掉，所以需要使用如下代码上传才行:<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -f .dockerignore</span><br></pre></td></tr></tbody></table></figure></li>
<li>在pycharm中使用docker进行操作:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27114995">https://zhuanlan.zhihu.com/p/27114995</a></li>
</ol>
</body></html>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/22/docker/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Spring Wang"
    src="/images/head.png">
  <p class="site-author-name" itemprop="name">Spring Wang</p>
  <div class="site-description" itemprop="description">众里寻他千百度，蓦然回首，那人却在灯火阑珊处</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lichun-wang" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;lichun-wang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/lichun_wang1993@163.com" title="E-Mail &amp;rarr; lichun_wang1993@163.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Chunfengyanyulove" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;Chunfengyanyulove" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/chunfengyanyu" title="Weibo &amp;rarr; https:&#x2F;&#x2F;weibo.com&#x2F;chunfengyanyu" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Spring Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.5.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Lgw7TumxtycA4MCC8Ro8gL4a-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'Lgw7TumxtycA4MCC8Ro8gL4a-gzGzoHsz',
            'X-LC-Key': 'VAwpszUEpH7osEG3O76jh3be',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Lgw7TumxtycA4MCC8Ro8gL4a-gzGzoHsz',
    appKey: 'VAwpszUEpH7osEG3O76jh3be',
    placeholder: "comments",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
